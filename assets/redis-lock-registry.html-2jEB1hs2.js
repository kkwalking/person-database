import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,d as i}from"./app-BPCwfPpp.js";const r={},n=i('<h1 id="redislockregistry的介绍及源码详解" tabindex="-1"><a class="header-anchor" href="#redislockregistry的介绍及源码详解"><span>RedisLockRegistry的介绍及源码详解</span></a></h1><h2 id="_1-分布式锁理论介绍" tabindex="-1"><a class="header-anchor" href="#_1-分布式锁理论介绍"><span>1. 分布式锁理论介绍</span></a></h2><h3 id="_1-1-什么是分布式锁" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是分布式锁"><span>1.1 什么是分布式锁？</span></a></h3><p>何为分布式锁，为什么需要分布式锁？在解答这个问题之前，需要先介绍本地锁的概念。Java提供了synchronized关键字和juc中的Lock锁，这两者都是本地锁。本地锁指的是，该锁只针对当前虚拟机有效，也就是当你部署运行了一个Java项目A并且获取锁时，新起另一个Java项目，同样还可以获取锁，这两个锁之间没有任何关系。这便属于本地锁。因此，当你的服务只需要部署一个节点时，那么只需要用到本地锁即可。当你的系统需要支撑高并发、高性能等特性而去部署多节点时，本地锁便不够用了。本地锁无法解决多节点之间的资源竞争问题。因此，便需要用到分布式锁。在分布式锁中，当一个节点获取到锁后，其余节点在该锁被释放前均不可以获取锁。 如何实现分布式锁？分布式锁没有那么玄乎，其实就是将资源竞争条件从单个节点中拎出来，放到一个公共的、各节点均可以访问到的地方，各节点都共同去争抢这个锁。这样，大家就都能看到这个锁的争抢情况，自然可以进行锁的调度管控。</p><h3 id="_1-2-分布式锁理论的简单图示" tabindex="-1"><a class="header-anchor" href="#_1-2-分布式锁理论的简单图示"><span>1.2 分布式锁理论的简单图示</span></a></h3><p>如下图所示，一开始，三个节点共同去争抢一把锁 <img src="http://zzk31.320.io//img/20240403095528.png" alt="图1" loading="lazy"> 接着，节点A率先抢到了这个锁 <img src="http://zzk31.320.io/img/20240403095923.png" alt="图2" loading="lazy"> 在节点A执行完锁内操作后，释放了这把锁，另外两个节点继续争抢该锁 <img src="http://zzk31.320.io/img/20240403100024.png" alt="" loading="lazy"></p><h2 id="_2-redislockregistry的基本使用" tabindex="-1"><a class="header-anchor" href="#_2-redislockregistry的基本使用"><span>2. RedisLockRegistry的基本使用</span></a></h2><p>Spring提供了一套分布式锁的解决方案———RedisLockRegistry</p><h3 id="_2-1-简单入门使用" tabindex="-1"><a class="header-anchor" href="#_2-1-简单入门使用"><span>2.1 简单入门使用</span></a></h3><h3 id="_2-2-工具封装" tabindex="-1"><a class="header-anchor" href="#_2-2-工具封装"><span>2.2 工具封装</span></a></h3><h2 id="_3-源码详解" tabindex="-1"><a class="header-anchor" href="#_3-源码详解"><span>3. 源码详解</span></a></h2><h3 id="_3-1" tabindex="-1"><a class="header-anchor" href="#_3-1"><span>3.1</span></a></h3><h2 id="_4-参考文章" tabindex="-1"><a class="header-anchor" href="#_4-参考文章"><span>4. 参考文章</span></a></h2><ul><li>https://juejin.cn/post/6924573058674098184</li><li>https://juejin.cn/post/6844904041185558536?searchId=20240402230806574C1E91E47F3A2F6C0A</li></ul>',14),s=[n];function o(c,l){return t(),a("div",null,s)}const p=e(r,[["render",o],["__file","redis-lock-registry.html.vue"]]),g=JSON.parse('{"path":"/java/redis-lock-registry.html","title":"RedisLockRegistry的介绍及源码详解","lang":"zh-CN","frontmatter":{"title":"RedisLockRegistry的介绍及源码详解","date":"2024-04-02T00:00:00.000Z","tag":["Java"],"description":"RedisLockRegistry的介绍及源码详解 1. 分布式锁理论介绍 1.1 什么是分布式锁？ 何为分布式锁，为什么需要分布式锁？在解答这个问题之前，需要先介绍本地锁的概念。Java提供了synchronized关键字和juc中的Lock锁，这两者都是本地锁。本地锁指的是，该锁只针对当前虚拟机有效，也就是当你部署运行了一个Java项目A并且获取锁...","head":[["meta",{"property":"og:url","content":"https://shzyjbr.github.com/person-database/person-database/java/redis-lock-registry.html"}],["meta",{"property":"og:site_name","content":"zzk的个人知识库"}],["meta",{"property":"og:title","content":"RedisLockRegistry的介绍及源码详解"}],["meta",{"property":"og:description","content":"RedisLockRegistry的介绍及源码详解 1. 分布式锁理论介绍 1.1 什么是分布式锁？ 何为分布式锁，为什么需要分布式锁？在解答这个问题之前，需要先介绍本地锁的概念。Java提供了synchronized关键字和juc中的Lock锁，这两者都是本地锁。本地锁指的是，该锁只针对当前虚拟机有效，也就是当你部署运行了一个Java项目A并且获取锁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://zzk31.320.io//img/20240403095528.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-03T02:17:30.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"RedisLockRegistry的介绍及源码详解"}],["meta",{"property":"article:author","content":"zzk"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2024-04-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-03T02:17:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RedisLockRegistry的介绍及源码详解\\",\\"image\\":[\\"http://zzk31.320.io//img/20240403095528.png\\",\\"http://zzk31.320.io/img/20240403095923.png\\",\\"http://zzk31.320.io/img/20240403100024.png\\"],\\"datePublished\\":\\"2024-04-02T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-03T02:17:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"zzk\\",\\"url\\":\\"https://github.com/shzyjbr\\"}]}"]]},"headers":[{"level":2,"title":"1. 分布式锁理论介绍","slug":"_1-分布式锁理论介绍","link":"#_1-分布式锁理论介绍","children":[{"level":3,"title":"1.1 什么是分布式锁？","slug":"_1-1-什么是分布式锁","link":"#_1-1-什么是分布式锁","children":[]},{"level":3,"title":"1.2 分布式锁理论的简单图示","slug":"_1-2-分布式锁理论的简单图示","link":"#_1-2-分布式锁理论的简单图示","children":[]}]},{"level":2,"title":"2. RedisLockRegistry的基本使用","slug":"_2-redislockregistry的基本使用","link":"#_2-redislockregistry的基本使用","children":[{"level":3,"title":"2.1 简单入门使用","slug":"_2-1-简单入门使用","link":"#_2-1-简单入门使用","children":[]},{"level":3,"title":"2.2 工具封装","slug":"_2-2-工具封装","link":"#_2-2-工具封装","children":[]}]},{"level":2,"title":"3. 源码详解","slug":"_3-源码详解","link":"#_3-源码详解","children":[{"level":3,"title":"3.1","slug":"_3-1","link":"#_3-1","children":[]}]},{"level":2,"title":"4. 参考文章","slug":"_4-参考文章","link":"#_4-参考文章","children":[]}],"git":{"createdTime":1712110650000,"updatedTime":1712110650000,"contributors":[{"name":"zhouzekun","email":"zhouzk3@chinatelecom.cn","commits":1}]},"readingTime":{"minutes":1.79,"words":536},"filePathRelative":"java/redis-lock-registry.md","localizedDate":"2024年4月2日","excerpt":"\\n<h2>1. 分布式锁理论介绍</h2>\\n<h3>1.1 什么是分布式锁？</h3>\\n<p>何为分布式锁，为什么需要分布式锁？在解答这个问题之前，需要先介绍本地锁的概念。Java提供了synchronized关键字和juc中的Lock锁，这两者都是本地锁。本地锁指的是，该锁只针对当前虚拟机有效，也就是当你部署运行了一个Java项目A并且获取锁时，新起另一个Java项目，同样还可以获取锁，这两个锁之间没有任何关系。这便属于本地锁。因此，当你的服务只需要部署一个节点时，那么只需要用到本地锁即可。当你的系统需要支撑高并发、高性能等特性而去部署多节点时，本地锁便不够用了。本地锁无法解决多节点之间的资源竞争问题。因此，便需要用到分布式锁。在分布式锁中，当一个节点获取到锁后，其余节点在该锁被释放前均不可以获取锁。\\n如何实现分布式锁？分布式锁没有那么玄乎，其实就是将资源竞争条件从单个节点中拎出来，放到一个公共的、各节点均可以访问到的地方，各节点都共同去争抢这个锁。这样，大家就都能看到这个锁的争抢情况，自然可以进行锁的调度管控。</p>","autoDesc":true}');export{p as comp,g as data};
