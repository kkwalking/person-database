<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://shzyjbr.github.com/person-database/person-database/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://shzyjbr.github.com/person-database/person-database/rss.xml" rel="self" type="application/rss+xml"/>
    <title>zzk的个人知识库</title>
    <link>https://shzyjbr.github.com/person-database/person-database/</link>
    <description>欢迎来到zzk的个人知识库</description>
    <language>zh-CN</language>
    <pubDate>Sat, 06 Apr 2024 13:08:23 GMT</pubDate>
    <lastBuildDate>Sat, 06 Apr 2024 13:08:23 GMT</lastBuildDate>
    <generator>@vuepress/plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>中间件</category>
    <category>项目实践</category>
    <item>
      <title>如何实现一个分布式锁</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/how-to-write-a-distributed-lock.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/how-to-write-a-distributed-lock.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">如何实现一个分布式锁</source>
      <description>如何实现一个分布式锁 关于分布式锁的基本知识，可以参考我先前的一篇文章：。 本篇内容主要介绍如何使用 Java 语言实现一个注解式的分布式锁，主要是通过注解+AOP 环绕通知来实现。 1. 锁注解 我们首先写一个锁的注解 expiredTime 是设置锁的过期时间，timeoutForLock 是设置等待锁的超时时间。如果没有等待获得锁的超时时间这个功...</description>
      <pubDate>Fri, 05 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>关于分布式锁的基本知识，可以参考我先前的一篇文章：<a href="/person-database/java/distributed-lock-introduction.html" target="_blank">分布式锁理论介绍</a>。</p>
<p>本篇内容主要介绍如何使用 Java 语言实现一个注解式的分布式锁，主要是通过注解+AOP 环绕通知来实现。</p>
<h2>1. 锁注解</h2>
<p>我们首先写一个锁的注解</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 分布式锁注解
 */</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">RedisLock</span> <span class="token punctuation">{</span>

    <span class="token keyword">long</span> <span class="token constant">DEFAULT_TIMEOUT_FOR_LOCK</span> <span class="token operator">=</span> <span class="token number">5L</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token constant">DEFAULT_EXPIRE_TIME</span> <span class="token operator">=</span> <span class="token number">60L</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"your-biz-key"</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> <span class="token function">expiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token constant">DEFAULT_EXPIRE_TIME</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> <span class="token function">timeoutForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token constant">DEFAULT_TIMEOUT_FOR_LOCK</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>expiredTime 是设置锁的过期时间，timeoutForLock 是设置等待锁的超时时间。如果没有等待获得锁的超时时间这个功能，那么其他线程在获取锁失败时只能直接失败，无法进行排队等待。</p>
<p>我们如何使用这个注解呢，很容易，在需要加锁的业务方法上直接用就行.如下，我们有一个库存服务类，它有一个扣减库存方法，该方法将数据库中的一个库存商品的数量减一。在并发场景下，如果我们没有对其进行资源控制，必然会发生库存扣减不一致现象。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StockServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@RedisLock</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"stock-lock"</span><span class="token punctuation">,</span> expiredTime <span class="token operator">=</span> <span class="token number">10L</span><span class="token punctuation">,</span> timeoutForLock <span class="token operator">=</span> <span class="token number">5L</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token class-name">Long</span> stockId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Stock</span> stock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> count <span class="token operator">=</span> stock<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stock<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>stock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>2. 在 AOP 切面中进行加锁处理</h2>
<p>我们需要使用 AOP 来处理什么？自然是处理使用<code>@RedisLock</code>的方法，因此我们写一个切点表达式，它匹配所有标有 @RedisLock 注解的方法。</p>
<p>接着，我们将此切点表达式与 @Around 注解结合使用，以创建环绕通知，在目标方法执行前后执行我们的加锁解锁逻辑。
因此，基本的逻辑我们就理清了，代码大致长下面这个样子:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisLockAspect</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>

    <span class="token comment">// 锁的redis key前缀</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DEFAULT_KEY_PREFIX</span> <span class="token operator">=</span> <span class="token string">"lock:"</span><span class="token punctuation">;</span>

    <span class="token comment">// 匹配所有标有 @RedisLock 注解的方法</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.kelton.lock.annotation.RedisLock)"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockAnno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>


    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"lockAnno()"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取拦截方法上的RedisLock注解</span>
        <span class="token class-name">RedisLock</span> annotation <span class="token operator">=</span> <span class="token function">getLockAnnotationOnMethod</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取锁key</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 锁过期时间</span>
        <span class="token keyword">long</span> expireTime <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">expiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取锁的等待时间</span>
        <span class="token keyword">long</span> timeoutForLock <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">timeoutForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 在这里加锁</span>
        someCodeForLock<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">// 执行业务</span>
        joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 在这里解锁</span>
        someCodeForUnLock<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

</code></pre></div><p>我们在加锁的时候，需要用上 timeoutForLock 这个属性，我们通过自旋加线程休眠的方式，来达到在一段时间内等待获取锁的目的。如果自旋时间结束后，还没获取锁，则抛出异常，这里可以根据自己情况而定。自旋加锁代码如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>        <span class="token comment">// 自旋获取锁</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeoutForLock <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> acquired <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> uuid <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> endTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Boolean</span> absent <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>absent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                acquired <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 获取不到锁，尝试休眠100毫秒后重试</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 超时未获取到锁， 抛出异常，可根据自己业务而定</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acquired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"获取锁异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>我们发现上面加锁的时候设置了一个 uuid 作为 value 值，这是为了在锁释放的时候，不误删其他线程上的锁，具体可以参考我先前的一篇文章：<a href="/person-database/java/distributed-lock-introduction.html" target="_blank">分布式锁理论介绍</a>。随后，我们就可以执行被 AOP 切中的方法，执行结束释放锁。代码如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 执行业务</span>
            joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"业务执行出错！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 解锁时进行校验，只删除自己线程加的锁</span>
            <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"锁已过期！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>到这里，我们就以注解+AOP 的方式实现了分布式锁的功能。当然，以上只实现了分布式锁的简单功能，还缺少了分布式锁的 key 自动续约防止锁过期功能，以及锁重入功能。</p>
<p>目前，<code>RedisLockAspect</code>的完整代码如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisLockAspect</span> <span class="token punctuation">{</span>

    <span class="token comment">// 匹配所有标有 @RedisLock 注解的方法</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.kelton.lock.annotation.RedisLock)"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockAnno</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>


    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"lockAnno()"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取拦截方法上的RedisLock注解</span>
        <span class="token class-name">RedisLock</span> annotation <span class="token operator">=</span> <span class="token function">getLockAnnotationOnMethod</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 锁过期时间</span>
        <span class="token keyword">long</span> expireTime <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">expiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取锁的等待时间</span>
        <span class="token keyword">long</span> timeoutForLock <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">timeoutForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 自旋获取锁</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeoutForLock <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> acquired <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> uuid <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> endTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Boolean</span> absent <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>absent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                acquired <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 获取不到锁，尝试休眠100毫秒后重试</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 超时未获取到锁， 抛出异常，可根据自己业务而定</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acquired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"获取锁异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 执行业务</span>
            joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"业务执行出错！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 解锁时进行校验，只删除自己线程加的锁</span>
            <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"锁已过期！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token class-name">RedisLock</span> redisLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>redisLock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">DEFAULT_KEY_PREFIX</span> <span class="token operator">+</span> <span class="token string">"default"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">DEFAULT_KEY_PREFIX</span> <span class="token operator">+</span> redisLock<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">RedisLock</span> <span class="token function">getLockAnnotationOnMethod</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MethodSignature</span> signature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodSignature</span><span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">RedisLock</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h2>3. key 自动续约防止锁过期</h2>
<p>我们接着完善该分布式锁，为其添加 key 自动续约防止锁过期的功能。我们的思路与<em>Redission</em>的<em>watch dog</em>类似，开启一个后台线程，来定时检查需要续约的锁。我们如何判断一个锁是否需要续约呢，我们可以简单定义一个续约分界线，比如在锁过期时间的三分之二的时间点及之后，对锁进行续约。</p>
<h3>3.1 定义一个续约任务</h3>
<p>我们来定义一个锁续约任务，那我们需要什么信息呢？</p>
<p>我们至少需要锁的 key，锁要设置的过期时间。这是两个最基本的信息。</p>
<p>要判断在锁过期时间的三分之二的时间点及之后进行续约，那么我们还需要记录锁上次续约的时间点。</p>
<p>此外，我们还可以为锁续约任务添加最大续约次数限制，这可以避免某些执行时间特别久的任务不断占用锁。所以我们还需要记录当前锁续约次数和最大续约次数。</p>
<p>对超过最大续约次数的锁的线程，我们直接将其停止，因此我们也记录一下该锁的线程。</p>
<p>结合上面的分析，我们定义的锁续约任务类如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockRenewTask</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * key
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 过期时间。单位：秒
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> expiredTime<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 锁的最大续约次数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> maxRenewCount<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 锁的当前续约次数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> currentRenewCount<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 最新更新时间
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">LocalDateTime</span> latestRenewTime<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 业务线程
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LockRenewTask</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> expiredTime<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRenewCount<span class="token punctuation">,</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>expiredTime <span class="token operator">=</span> expiredTime<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maxRenewCount <span class="token operator">=</span> maxRenewCount<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>latestRenewTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/**
     * 是否到达续约时间
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isTimeToRenew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Duration</span> duration <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>latestRenewTime<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> duration<span class="token punctuation">.</span><span class="token function">toSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>expiredTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/**
     * 是否达到最大续约次数
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exceedMaxRenewCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentRenewCount <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxRenewCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">renew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>currentRenewCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>latestRenewTime <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 取消业务方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> expiredTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们添加了一些关于锁续约的方法：</p>
<ul>
<li><code>isTimeToRenew()</code>: 判断是否可以对锁进行续约</li>
<li><code>exceedMaxRenewCount()</code>: 判断是否达到最大续约次数</li>
<li><code>renew()</code>: 来标记一次续约操作</li>
<li><code>cancel()</code>: 取消业务方法</li>
</ul>
<h3>3.2 定义一个锁续约任务处理器</h3>
<p>接着，我们定义一个定时执行该续约任务的 handler。该 handler 也比较简答，核心逻辑是持有一个类型为 <code>List&lt;LockRenewTask&gt;</code>的 taskList 来添加续约任务，且使用一个 ScheduledExecutorService 来定时遍历该 taskList 来执行续约任务。该 handler 再对外暴露一个 addRenewTask 方法，方便外部调用来添加续约任务到 taskList 中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockRenewHandler</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 保障对 taskList的添加删除操作是线程安全的
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> taskListLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LockRenewTask</span><span class="token punctuation">&gt;</span></span> taskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ScheduledExecutorService</span> taskExecutorService<span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        taskExecutorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        taskExecutorService<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">executeRenewTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//错误处理</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/**
     * 添加续约任务
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRenewTask</span><span class="token punctuation">(</span><span class="token class-name">LockRenewTask</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        taskListLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            taskList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            taskListLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/**
     * 执行续约任务
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">executeRenewTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"开始执行续约任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>taskList<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 需要删除的任务，暂存这个集合中  取消</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LockRenewTask</span><span class="token punctuation">&gt;</span></span> cancelTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取任务副本</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LockRenewTask</span><span class="token punctuation">&gt;</span></span> copyTaskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>taskList<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">LockRenewTask</span> task <span class="token operator">:</span> copyTaskList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 判断 Redis 中是否存在 key</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    cancelTask<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 大于等于最大续约次数</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">exceedMaxRenewCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 停止续约任务</span>
                    task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cancelTask<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 到达续约时间</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">isTimeToRenew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"续约任务：{}"</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span><span class="token function">getExpiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    task<span class="token punctuation">.</span><span class="token function">renew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//错误处理</span>
                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"处理任务出错：{}"</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 加锁，删除 taskList 中需要移除的任务</span>
        taskListLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            taskList<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>cancelTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 清理cancelTask,避免堆积，产生内存泄露</span>
            cancelTask<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            taskListLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总结一下 <code>LockRenewHandler</code>的主要作用：它负责管理和执行续约任务，以延长 Redis 中键的过期时间。</p>
<ul>
<li><strong>添加续约任务</strong>：<code>addRenewTask()</code> 方法允许添加新的续约任务到内部列表 <code>taskList</code> 中。</li>
<li><strong>执行续约任务</strong>：<code>executeRenewTask()</code> 方法定期执行续约任务。它检查每个任务的状态，并根据需要续约 Redis 中的键。</li>
<li><strong>移除完成的任务</strong>：维护一个 <code>cancelTask</code> 列表，用于存储需要从 <code>taskList</code> 中移除的任务。在 <code>executeRenewTask()</code> 方法中，它会将完成的任务添加到 <code>cancelTask</code> 列表中，并在之后将其从 <code>taskList</code> 中移除。</li>
</ul>
<p><strong>大概的工作流程如下</strong>：</p>
<ol>
<li>续约任务被添加到 <code>taskList</code> 中。</li>
<li><code>executeRenewTask()</code> 方法定期执行，它检查每个任务的状态：
<ul>
<li>如果 Redis 中不再存在该键，则取消任务。</li>
<li>如果任务的续约次数达到上限，则取消任务。</li>
<li>如果是时候续约了，则续约 Redis 中的键并更新任务的续约次数，记录续约时间点。</li>
</ul>
</li>
<li>完成的任务被添加到 <code>cancelTask</code> 列表中。</li>
<li><code>executeRenewTask()</code> 方法获取 <code>taskList</code> 的副本，并从副本中移除 <code>cancelTask</code> 中的任务，并且在完成移除任务操作后清空<code>cancelTask</code>。</li>
<li>更新后的 <code>taskList</code> 被保存回类中。</li>
</ol>
<p>两个需要注意的点</p>
<ul>
<li>我们遍历<code>taskList</code>时拷贝了一份副本进行遍历，因为<code>taskList</code>是可变的，这样可以避免在遍历的时候产生并发修改问题。</li>
<li><code>cancelTask</code>需要清理，避免产生内存泄漏。</li>
</ul>
<p>通过这种方式，<code>LockRenewHandler</code> 可以确保 Redis 中的键在需要时得到续约，并自动移除完成或失败的任务。</p>
<h3>3.3 添加锁续约任务</h3>
<p>在上面 3.1 节和 3.2 节我们定义好了锁续约任务和处理锁续约任务的核心代码，接下来我们需要在第 2 节加锁解锁的 AOP 处理逻辑上进行一点小小的修改，主要就是在执行加锁之后，执行业务代码之前，添加上锁续约任务。修改位置如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 省略代码</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 添加锁续约任务</span>
            <span class="token class-name">LockRenewTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockRenewTask</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> annotation<span class="token punctuation">.</span><span class="token function">expiredTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> annotation<span class="token punctuation">.</span><span class="token function">maxRenew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            lockRenewHandler<span class="token punctuation">.</span><span class="token function">addRenewTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"添加续约任务, key:{}"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 执行业务</span>
            joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"业务执行出错！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 解锁时进行校验，只删除自己线程加的锁</span>
            <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"锁已过期！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 省略代码</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>到这里，我们的分布式锁已经相当完善了，把锁自动续约的功能也加上了。当然，还没有实现锁的可重入性。如果你有好的点子，欢迎到仓库提 issue 反馈。</p>
<div class="hint-container tip">
<p class="hint-container-title">拉个 Star</p>
<ul>
<li>看到这里，如果<a href="https://github.com/shzyjbr/person-database" target="blank">本篇文章</a>的内容帮助到你，还请点个免费的 Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>分布式锁理论介绍</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/distributed-lock-introduction.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/distributed-lock-introduction.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">分布式锁理论介绍</source>
      <description>分布式锁理论介绍 闲话漫谈： 本来是想要写一篇关于 Spring 提供的 RedisLockRegistry 的使用方法及底层原理解析的文章，写着写着发现得先介绍一下分布式锁的基本原理，才能有助于理解一些实现内容。最后发现关于分布式锁的基本介绍也占据了较大篇幅，因此另开一篇，介绍一下分布式锁。 1. 什么是分布式锁？ 何为分布式锁，为什么需要分布式锁？...</description>
      <pubDate>Thu, 04 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<blockquote>
<p>闲话漫谈： 本来是想要写一篇关于 Spring 提供的 RedisLockRegistry 的使用方法及底层原理解析的文章，写着写着发现得先介绍一下分布式锁的基本原理，才能有助于理解一些实现内容。最后发现关于分布式锁的基本介绍也占据了较大篇幅，因此另开一篇，介绍一下分布式锁。</p>
</blockquote>
<h2>1. 什么是分布式锁？</h2>
<p>何为分布式锁，为什么需要分布式锁？在解答这个问题之前，需要先介绍本地锁的概念。Java 提供了 synchronized 关键字和 juc 中的 Lock 锁，这两者都是本地锁。本地锁指的是，该锁只针对当前虚拟机有效，也就是当你部署运行了一个 Java 项目 A 并且获取锁时，新起另一个 Java 项目，同样还可以获取锁，这两个锁之间没有任何关系。这便属于本地锁。因此，当你的服务只需要部署一个节点时，那么只需要用到本地锁即可。当你的系统需要支撑高并发、高性能等特性而去部署多节点时，本地锁便不够用了。本地锁无法解决多节点之间的资源竞争问题。因此，便需要用到分布式锁。在分布式锁中，当一个节点获取到锁后，其余节点在该锁被释放前均不可以获取锁。
如何实现分布式锁？分布式锁没有那么玄乎，其实就是将资源竞争条件从单个节点中拎出来，放到一个公共的、各节点均可以访问到的地方，各节点都共同去争抢这个锁。这样，大家就都能看到这个锁的争抢情况，自然可以进行锁的调度管控。</p>
<h2>2. 分布式锁理论的简单图示</h2>
<p>如下图所示，一开始，三个节点共同去争抢一把锁</p>
<figure><img src="http://zzk31.320.io//img/20240403095528.png" alt="图1" tabindex="0" loading="lazy"><figcaption>图1</figcaption></figure>
<p>接着，节点 A 率先抢到了这个锁</p>
<figure><img src="http://zzk31.320.io/img/20240403095923.png" alt="图2" tabindex="0" loading="lazy"><figcaption>图2</figcaption></figure>
<p>在节点 A 执行完锁内操作后，释放了这把锁，另外两个节点继续争抢该锁</p>
<figure><img src="http://zzk31.320.io/img/20240403100024.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2>3. 分布式锁的特征</h2>
<p>为了能够稳定可靠的实现上述目的，一个分布式锁需要具备以下特征：</p>
<ul>
<li>互斥性: 任意时刻，只有一个客户端能持有锁。</li>
<li>锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li>
<li>可重入性:一个线程如果获取了锁之后,可以再次对其请求加锁。</li>
<li>高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li>
<li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li>
</ul>
<h2>4. Redis 分布式锁实现方式简介</h2>
<p>分布式锁的实现可以有多种方式，目前比较熟知的有 Zookeeper、数据库和 Redis 实现。我们这里主要介绍在 Redis 中实现分布式锁。</p>
<p>先说一下 Redis 中实现分布式锁的基本理论。多个节点去同一个 Redis 服务设置一个相同的 key，谁先设置成功谁就抢到了该锁，未成功设置 key 的节点则等待锁释放（这里有两种方式，一种是节点主动定时去尝试设置该 key，失败了就说明该锁还在使用;另一种方式是利用 Redis 提供的发布订阅功能，节点订阅该 key，当该 key 失效时，redis 主动通知节点）。当然，一个 key 不能永远生效，节点需要为 key 设置过期时间，这段时间就是该节点持有该锁的时间。当该 key 过期，其他线程可以继续争抢该锁。因此，第 3 小节中提到的互斥性和锁超时释放得以基本实现。</p>
<p>Redis 为我们提供了<code>setnx</code>和<code>expire</code>命令。使用<code>setnx</code>来抢锁，如果抢到之后，再用<code>expire</code>为锁设置过期时间，防止锁忘记了释放。</p>
<p>然而 setnx 和 expire 是两个命令,并非原子操作。如果执行了<code>setnx</code>命令后，节点崩溃了，还没来得及执行<code>expire</code>命令，那么该锁就永远不会过期了，其他节点就永远无法获得该锁了。</p>
<blockquote>
<p>这里的原子操作与我们在数据库事务中用到的原子性并不等同。数据库事务中的原子性指“要么都成功要么都失败”。而我们这里的原子操作，仅是指操作不可被拆分，实际上 Redis 中执行 Lua 脚本即使出错也不会回滚。</p>
</blockquote>
<p>为了解决该问题，我们可以使用 Lua 脚本。Lua 脚本允许我们将多个命令打包执行,成为原子操作。</p>
<p>除了使用 Lua 脚本，保证 <code>setnx</code> + <code>expire</code> 两条指令的原子性，Redis 还为我们提供了 <code>set</code> 指令扩展参数，通过使用扩展参数，我们也可以实现上面的目的。</p>
<div class="language-Redis" data-ext="Redis" data-title="Redis"><pre class="language-Redis"><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]）
</code></pre></div><ul>
<li>EX seconds :设定 key 的过期时间，时间单位是秒。</li>
<li>PX milliseconds: 设定 key 的过期时间，单位为毫秒</li>
<li>NX :表示 key 不存在的时候，才能 set 成功。</li>
<li>XX: 表示 key 存在的时候，才能 set 成功。</li>
</ul>
<p>解决了设置 key 和为 key 设置过期时间两个命令的原子操作问题，我们还无法实现一把靠谱的分布式锁。假设这种场景：节点 a 获取锁成功，开始执行临界区代码。当锁过期了，节点 a 还没执行完临界区代码。此时节点 b 也请求过来，显然节点 b 是可以成功获得该锁的。节点 b 也开始执行临界区代码，那么临界区代码的互斥性串行性就被破坏了。此外，当节点 a 执行完临界区代码，去释放锁，然而此时节点 b 还没执行完临界区代码（节点 a 以为释放的是自己的锁）。这个问题同样很严重。一个节点的锁被另一个节点错误释放了，不满足 第 3 小节中提到<em>安全性</em>。</p>
<p>总结以下，上面提到的两个问题：</p>
<ol>
<li>锁过期释放了，节点的业务还未执行完。</li>
<li>锁被别的节点误删。</li>
</ol>
<p>我们先解决问题 2。为了防止节点上的锁被别的节点误删，我们可以将 value 值设置为一个能够标记当前节点的唯一值。在释放锁时，对 value 进行校验，仅释放属于当前节点上的锁。
伪代码如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>// 上锁
redisClient.set(key, clientId, "NX", "EX", expireTime) // clientId即是标记当前节点的唯一值
// 执行业务方法
doBusness()
// 比较并解锁
if compare(redisClient.get(key), clientId)
  redisClient.del(key)
</code></pre></div><p>上述比较 value 相等后删除 key 的操作也可以使用 Lua 脚本来实现原子操作</p>
<p>离设计一个靠谱的分布式锁越来越近了，我们还剩下一个问题没解决： 锁过期释放了，节点的业务还未执行完</p>
<p>一种简单的方法是将锁的过期时间设置得久一点，这当然也可以。
但是这种处理方式很不灵活，而且不同业务方法的执行时间不同，有的久一点，有的短一点。如果对所有业务方法都应用一个比较久的过期时间，那么系统的响应速度就会变慢，不足以称得上<em>高可用高性能</em></p>
<p>一个更好的方法是设置一个定时线程，周期性地检查锁，对即将过期的锁延长其过期时间，防止锁过期提前释放。在这方面，Java 的 Redission 便是采用了这种方式，其使用了一个 watch dog 机制来周期检查锁，对锁执行延长过期时间操作。</p>
<p>到这里，我们的分布式锁已经做到了<em>互斥性</em>、<em>锁超时释放</em>、<em>高性能高可用</em>和<em>安全性</em>，还剩下一个<em>可重入</em>特性还没实现。关于可重入，通常由具体的客户端来实现，比如 Spring 提供的 RedisLockRegistry，则是利用的 JDK 提供的 Lock 来实现可重入。</p>
<div class="hint-container tip">
<p class="hint-container-title">拉个 Star</p>
<ul>
<li>看到这里，如果<a href="https://github.com/shzyjbr/person-database" target="blank">本篇文章</a>的内容帮助到你，还请点个免费的 Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
]]></content:encoded>
      <enclosure url="http://zzk31.320.io//img/20240403095528.png" type="image/png"/>
    </item>
    <item>
      <title>RedisLockRegistry的介绍及源码详解</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/redis-lock-registry.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/redis-lock-registry.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">RedisLockRegistry的介绍及源码详解</source>
      <description>RedisLockRegistry 的介绍及源码详解 1. RedisLockRegistry 的基本使用 Spring 提供了一套分布式锁的解决方案———RedisLockRegistry 1.1 简单入门使用 1.2 工具封装 2. 源码详解 2.1 可重入 2.2 自旋等待、PubSub 机制 3. 参考文章 https://juejin.cn/...</description>
      <pubDate>Tue, 02 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<h2>1. RedisLockRegistry 的基本使用</h2>
<p>Spring 提供了一套分布式锁的解决方案———RedisLockRegistry</p>
<h3>1.1 简单入门使用</h3>
<h3>1.2 工具封装</h3>
<h2>2. 源码详解</h2>
<h3>2.1 可重入</h3>
<h3>2.2 自旋等待、PubSub 机制</h3>
<h2>3. 参考文章</h2>
<ul>
<li>https://juejin.cn/post/6924573058674098184</li>
<li>https://juejin.cn/post/6844904041185558536?searchId=20240402230806574C1E91E47F3A2F6C0A</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>关于死锁的一点笔记</title>
      <link>https://shzyjbr.github.com/person-database/person-database/operating-system/deadlock.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/operating-system/deadlock.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">关于死锁的一点笔记</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 声明：以下内容均来自书籍《现代操作系统》，内容略有改动。 1.资源 死锁的产生与资源相关，因而先给出资源的定义：在进程对设备、文件等取得排他性访问权时，有可能会出现死锁，为便于讨论，把这类需要排他性使用的对象称为资源（resource）。资源可以是硬件设备（如...</description>
      <pubDate>Wed, 05 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<blockquote>
<p>声明：以下内容均来自书籍《现代操作系统》，内容略有改动。</p>
</blockquote>
<h3>1.资源</h3>
<p>死锁的产生与资源相关，因而先给出资源的定义：在进程对设备、文件等取得排他性访问权时，有可能会出现死锁，为便于讨论，把这类需要排他性使用的对象称为资源（resource）。资源可以是硬件设备（如打印机），或是一组信息（如数据库中一条加锁的记录）。简而言之，资源是随着时间的推移，必须能获得、使用和释放的任何东西。</p>
<p>资源又分为可抢占资源和不可抢占资源。</p>
<p>可抢占资源可以从拥有它的进程中被抢占而不会产生任何副作用，存储器就是一类可抢占的资源。操作系统可以把一个进程从内存中换出，换入另一个进程。</p>
<p>不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。例如，一个进程使用打印机来打印内容，突然将打印机分配给另一个进程导致打印内容混乱。因此打印机属于不可抢占资源。</p>
<p>总的来说，死锁与不可抢占资源有关。</p>
<h3>2.资源获取</h3>
<p>使用信号量来管理资源，down操作来获取资源，使用资源，up操作来释放资源。如下所示。</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>tydedef int semaphore;
semaphore resource_1;
void process_A(void) {
    down(&amp;resource_1);
    use(&amp;resource_1);
    up(&amp;resource_1);
}
</code></pre></div><p>通常，进程需要两个或更多的资源，它们可以顺序获取，如下所示</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>tydedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
</code></pre></div><p>现在考虑两个进程（A和B）以及两个资源的情况。</p>
<p>第一种方式如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>typedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
void process_B(void) {
   down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
</code></pre></div><p>第二种方式如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>typedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
void process_B(void) {
    down(&amp;resource_2);
    down(&amp;resource_1);
    use_resources();
    up(&amp;resource_1);
    up(&amp;resource_2);
}
</code></pre></div><p>第一种方式中，两个进程以相同的次序请求资源，第二种方式中，两个进程请求资源的次序不同。这就可能造成不同的结果。</p>
<p>在第一种方式中，一个进程先于另一个进程获取资源，从而能够成功第二个资源并完成它的任务。如果另一个进程想在第一个资源被释放之前获取该资源，则会由于资源被加锁而被阻塞，直到该资源可用为止。然而在第二种方式中，则有产生死锁的风险。可能进程A获取了资源1，进程B获取了资源2，这时两个进程都想请求还未拥有的另一个资源，然而都会因此被阻塞，两个进程都无法继续运行。</p>
<h3>3.死锁</h3>
<p>死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
<p>死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源，但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以唤醒。进程的数量以及占有或者请求的资源数量和种类都是无关紧要的。这种死锁称为资源死锁（resource deadlock）。资源死锁很常见，但不是唯一类型。</p>
<h4>3.1 资源死锁的条件</h4>
<p>Coffman等人总结了发生资源死锁的四个必要条件：</p>
<ul>
<li>互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待条件。已经得到了某个资源的进程，可以再申请新的资源。</li>
<li>不可抢占条件。已经分配给某一个进程的资源，不能被强制性地抢占，它只能由占有它的进程显式地释放。</li>
<li>循环等待条件。死锁发生时，系统中一定有两个或以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</li>
</ul>
<p>有四种处理死锁的策略：</p>
<ul>
<li>忽略该问题。</li>
<li>检测死锁并从中恢复。</li>
<li>避免死锁。通过仔细对资源进行分配，可以动态地避免死锁。</li>
<li>防止死锁。通过破坏引起死锁的四个必要条件之一，防止死锁的产生。</li>
</ul>
<h4>3.2 死锁检测和死锁恢复</h4>
<p>使用这种技术的系统不试图阻止死锁的产生，而是允许死锁的发生，当检测到死锁发生后，采取措施进行恢复。</p>
<h5>3.2.1 每种类型一个资源的死锁检测</h5>
<p>死锁检测方法有多种，从简单的例子开始，即每种资源类型只有一个资源。例如，扫描仪、光盘驱动、绘图仪和打印机（仅有一台的情况）。</p>
<p>针对这种系统可以构造一张资源分配图</p>
<p>其中，圆圈指代进程，正方形指代资源</p>
<ol>
<li>A进程持有R资源，且需要S资源。</li>
<li>B进程不持有任何资源，但需要T资源</li>
<li>C进程不持有任何资源，但需要S资源。</li>
<li>D进程持有U资源，且需要S资源和T资源。</li>
<li>E进程持有T资源，且需要V资源。</li>
<li>F进程持有W资源，且需要S资源。</li>
<li>G进程持有V资源，且需要U资源。</li>
</ol>
<p>![image-20210306164921075](D:\OneDrive - e.gzhu.edu.cn\文档\blog\image-20210306164921075.png)</p>
<p>现在检测死锁的产生。从图中可以看出存在一个环（DTEVGUD），其中D、E、G已经死锁。这样的图虽然可以看出死锁进程，但是我们需要一个正规的算法来检测死锁。有很多检测有向图环路的方法。下面给出一个简单的算法，检测有向图是否存在环。这一算法使用数据结构L，L代表一些节点的集合，通过对已经检测的有向边进行标记，避免重复检查。算法流程如下：</p>
<ol>
<li>对图中的每个节点N，将N作为起始点执行下面五个步骤。</li>
<li>将L初始化为空表，并清除所有有向边标记。</li>
<li>将当前节点添加到L尾部，检测该节点是否已经在L中出现两次。如果是，那么该图包含了一个环，算法结束。</li>
<li>从给定的节点开始，检测是否存在没有标记的从该节点出发的有向边。如果存在的话，进行第5步；如果不存在，跳到第6步。</li>
<li>随机选取一条没有标记的从该节点出发的有向边，标记它，然后将该边指向的节点作为新的当前节点，跳到第3步。</li>
<li>如果这一节点是起始节点，那么表明该图不存在任何环，算法结束。否则意味着我们走进了死胡同，所以需要移走该节点，返回到前一节点，并作为新的当前节点，跳转到第3步。</li>
</ol>
<p>这一算法实际上是依次将每一个节点作为一棵树的根节点进行深度</p>
<p>优先搜索，如果碰到已经遇到过的节点，那么就算找到一个环。如果从任何给定的节点出发的有向边都被穷举了，则回溯到前面的节点。如果回溯到根，并且不能再深入下去，那么从当前节点出发的子图中就不存在环。若所有节点都是如此，则整个图不存在环，即系统不存在死锁。</p>
<p>对上图应用这一算法。从R节点开始，依次是A、B、C、S、D、T、E、F，如果遇到一个环，则算法停止。</p>
<p>我们先从R节点开始，将L初始化为空表，将R添加到L中，接着移动到A，A添加到L中，L=[R,A]。从A到达S，L=[R,A,S]。S没有出发的边，所以回溯到A，同理再回溯到R，从而完成了对R为起点的检测。</p>
<p>现在以A为起点进行检测，置L为空表，由上一段分析我们很快就能完成对A的检测。</p>
<p>现在从B节点开始，一路顺着有向边到达D，此时L=[B,T,E,V,G,U,D]。此时随机选择一条边，如果选S，则是死路，将回溯到D。接着选T，此时出现了L=[B,T,E,V,G,U,D,T]，发现了环（检测到两个T），算法结束。</p>
<h5>3.2.2 每种类型多个资源的死锁检测</h5>
<p>每种类型多种资源的情况下，可以采用基于矩阵的算法来检测死锁。现在检测$P_1$到$P_n$这n个进程中是否存在死锁，假设资源类型有m种，$E_1$代表资源类型1，$E_2$代表资源类型2，$E_i$代表资源类型$i(1\le i\le m)$。$E$是现有资源向量，代表每种已存在的资源总数，比如资源类型1代表打印机，那么$E_1=2$表示系统有两台打印机。在任意时刻，某些资源被分配所以不可用。设A是可用资源向量，那么$A_i$表示当前可供使用的资源数。如果仅有的两台打印机被分配出去，那么$A_i=0$。</p>
<p>另外需要两个矩阵，$C$代表当前分配矩阵，$R$代表请求矩阵。C的第$i$行代表$P_i$当前所持有的每一种类型资源的资源数。所以，$C_{ij}$代表$P_i$所持有的资源$j$的数量。同理，$R_{ij}$代表$P_i$所需要的资源$j$的数量。四种数据结构分别表示如下。
$$
现有资源\
(E_1,E_2,E_3,...,E_m)
$$</p>
<p>$$
可用资源\
(A_1,A_2,A_3,...,A_m)
$$</p>
<p>$$
当前分配矩阵\
\left[
\begin{matrix}
C_{11}&amp;C_{12}&amp;C_{13}&amp; ... &amp;C_{1m}\
C_{21}&amp;C_{22}&amp;C_{23}&amp; ... &amp;C_{2m}\
\vdots &amp; \vdots &amp; \vdots &amp;  &amp; \vdots    \
C_{n1}&amp;C_{n2}&amp;C_{n3}&amp; ... &amp;C_{nm}\
\end{matrix}
\right]
$$</p>
<p>$$
请求矩阵\
\left[
\begin{matrix}
R_{11}&amp;R_{12}&amp;R_{13}&amp; ... &amp;R_{1m}\
R_{21}&amp;R_{22}&amp;R_{23}&amp; ... &amp;R_{2m}\
\vdots &amp; \vdots &amp; \vdots &amp;  &amp; \vdots    \
R_{n1}&amp;R_{n2}&amp;R_{n3}&amp; ... &amp;R_{nm}\
\end{matrix}
\right]
$$</p>
<p>这四种数据结构之间满足一个恒等式，即
$$
\sum_{i=1}^nC_{ij} + A_j = E_j
$$
上式表示，将所有已分配的资源$j$数量累加起来，并且加上资源j的可用资源数，等于该类资源的总数。</p>
<p>定义向量A和向量B之间的关系为$A\le B$当且仅当$A_i \le B_i(0 \le i \le m)$。</p>
<p>规定：每个进程初始未被标记，当算法开始后，会对进程做标记，被标记后即表明该进程能够被执行，不会进入死锁。因此，当算法结束时，未被标记的进程都是死锁进程。</p>
<p>死锁检测算法如下：</p>
<ol>
<li>需要一个没有标记的进程$P_i$，对于它而言R矩阵的第$i$行向量小于或等于A，即$R_{i}\le A$.</li>
<li>如果找到这样一个进程，那么将C矩阵的第$i$行向量加到A中（因为资源足够该进程运行），标记该进程，并转到第1步。</li>
<li>如果没有这样的进程，算法结束。</li>
</ol>
<h5>3.2.3 何时去检测死锁</h5>
<p>知道了如何去检测死锁，那么该在何时去检测他们呢。一种方法是每当有资源请求时就去检测，这种方法会占用昂贵的CPU时间；另一种方法是定时检测，可以每个$k$分钟检测一次，又或者在CPU使用率降到某一阈值时去检测，依据是如果死锁进程数达到一定数量，就没有多少进程可运行，那么CPU会空闲下来。</p>
<h5>3.2.4 从死锁中恢复</h5>
<p>从死锁中恢复有如下方法：</p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>杀死进程恢复</li>
</ul>
<p>抢占恢复将资源从持有进程A拿走，分配给另一个进程B，待进程B使用完毕后再分配给进程A。</p>
<p>回滚恢复需要对进程设置<strong>检查点检查</strong>。进程检查点检查就是将进程写入一个文件以备以后重启。该检查点中不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，再此时间点之前该进程获取了一些其他的资源，而在此时间点之后该进程所做的所有工作都丢失。实际上是将该进程复位到一个更早的状态，那时它还没有取得导致死锁的资源，接着将该资源分配给一个死锁进程。</p>
<p>杀死一个或若干个进程是最直接也是最简单的解决死锁的方法。一种方法是杀掉环中的一个进程，使得其他进程可以继续，如无法继续，则再杀掉一个进程，直到打破死锁循环。另一种方法是选一个环外的进程作为牺牲品，释放该进程的资源。这种方法需要小心选择一个环外进程，它应该正好持有环中某些进程需要的资源。杀死进程这类方法，最好是选择可以从头开始重新运行而不会带来副作用的进程。例如编译程序可以重新运行产生新的目标文件。</p>
<h4>3.3 死锁避免</h4>
]]></content:encoded>
    </item>
    <item>
      <title>浅谈单例模式</title>
      <link>https://shzyjbr.github.com/person-database/person-database/pattern-design/about-singleton-pattern.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/pattern-design/about-singleton-pattern.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">浅谈单例模式</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 浅谈单例模式 饿汉模式 缺点：在需要初始化许多对象的时候会导致系统启动较慢，比如在有许多个单例对象的容器中，启动该容器的初始过程会比较长。 懒加载模式 缺点：同步方法锁住了对象，降低了系统的处理速度。 错误的双重锁检查 这样的写法是有问题的。在JVM中， in...</description>
      <pubDate>Fri, 10 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>浅谈单例模式</h1>
<h4>饿汉模式</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>缺点：在需要初始化许多对象的时候会导致系统启动较慢，比如在有许多个单例对象的容器中，启动该容器的初始过程会比较长。</p>
<h4>懒加载模式</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>缺点：同步方法锁住了对象，降低了系统的处理速度。</p>
<h4>错误的双重锁检查</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的写法是有问题的。在JVM中， instance = new Singleton(); 语句并不是一个原子操作，分为创建对象和引用赋值两步。其中，创建对象需要为对象分配空间，再进行初始化。以上三步，分配内存永远是第一步，但是后面两步则可能被重排序。</p>
<p>JVM并不保证初始化先于引用赋值的顺序，因此很可能是先创建了对象，即在Singleton实例分配了内存空间，但是还未进行初始化，然后赋值给了<code>instance</code>，这是实例虽然分配到了空间，但是其并未完成初始化，而<code>instance</code>引用却不为空，这时另一个线程抢占执行，执行了<code>getInstance（）</code>方法，便会发现<code>instance</code>不为<code>null</code>，从而直接返回了<code>instance</code>，导致系统出错。</p>
<h4>正确的双重锁检查</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用volatile的内存可见性可以使得<code>instance</code>不会被线程缓存，所有的线程读写该对象都需要对主内存进行操作。</p>
<p>volatile还可以防止指令重排序，从而使得上述的双重锁检查代码正确执行。这里的防止指令重排序是指，volatile修饰的<code>instance</code>对象，在执行代码 <code>instance = new Singleton()</code>时不会再被JVM进行指令重排序，会按照 <code>内存分配 -&gt; 初始化 -&gt; 引用赋值</code> 的顺序执行</p>
<h4>使用静态内部类</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonFactory</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//序列化方法  可忽略</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的写法利用了JVM的类加载机制，JVM在加载类的过程中确保了线程互斥，是线程安全的。外部类被加载时，不会立即加载内部类，从而<code>instance</code>不会立即被实例化。当<code>getInstance()</code> 第一次被调用时，内部类第一次被引用，从而加载了内部类，并完成了<code>instance</code>的实例化，而JVM的类加载机制确保了实例化instance的过程中的线程安全性。</p>
<p>缺点：使用静态内部类的方式，则存在传参的问题，外部无法传递参数给内部类</p>
<h4>使用枚举</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//其他方法代码</span>
<span class="token punctuation">}</span>
</code></pre></div><p>枚举类型的实例创建出来天然就是单例的，并且是线程安全的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Redis学习笔记之链表</title>
      <link>https://shzyjbr.github.com/person-database/person-database/middleware/redis/redis-learn-list.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/middleware/redis/redis-learn-list.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">Redis学习笔记之链表</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 本系列是个人的Redis学习笔记，参考的书籍有《Redis设计与实现》、《Redis深度历险--核心原理与应用实践》，Redis源码版本是黄健宏老师注释的Redis-3.0-annotated版本 一、Redis中的链表应用场景 链表是一种应用非常广泛的数据结...</description>
      <category>中间件</category>
      <pubDate>Sat, 14 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<blockquote>
<p>本系列是个人的Redis学习笔记，参考的书籍有《Redis设计与实现》、《Redis深度历险--核心原理与应用实践》，Redis源码版本是黄健宏老师注释的<a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener noreferrer">Redis-3.0-annotated</a>版本</p>
</blockquote>
<h2>一、Redis中的链表应用场景</h2>
<p>链表是一种应用非常广泛的数据结构，在很多语言中都有相应的实现和使用，比如Java中的LinkedList。C语言中并没有内置的链表实现，因此Redis实现了自己的链表结构，并将它应用在许多场景，比如我们在Redis中使用的list，其底层就是用链表实现的。</p>
<p>Redis中的list是由字符串值组成的双向链表，其基本用法如下：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>127.0.0.1:6379&gt; lpush fruits apple banana orange
(integer) 3
127.0.0.1:6379&gt;
</code></pre></div><p>Redis中的list支持从两边对链表进行操作，其主要使用的命令有LPUSH，RPUSH，LPOP，RPOP。</p>
<p>利用这些命令，可以把list作为队列或者栈来使用。</p>
<p>比如组合使用LPUSH和RPOP，即左进右出，那么可以模拟成<strong>队列</strong>。当然也可以反过来，RPUSH和LPOP，即右进左出。比如像下面这样使用：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>127.0.0.1:6379&gt; lpush fruits apple banana orange
(integer) 3
127.0.0.1:6379&gt; rpop fruits
"apple"
</code></pre></div><h2>二、Redis的链表实现</h2>
<p>Redis中的链表实现与常见的链表差不多，基本结构有listNode和list。listNode是链表节点结构，list是链表结构。listNode的基本结构如下：</p>
<div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span>

    <span class="token comment">// 前置节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token comment">// 后置节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 节点的值</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>

<span class="token punctuation">}</span> listNode<span class="token punctuation">;</span>
</code></pre></div><p>next指针作为前向指针，可以沿着表头到表尾的方向进行遍历；prev指针作为后向指针，可以沿着表尾到表头的方向进行遍历；value是一个值指针。</p>
<p>使用listNode组成的双向链表结构如下所示:</p>
<figure><img src="http://zzk31.320.io/img/20230521171907.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>list的结构如下所示：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>typedef struct list {

    // 头节点
    listNode *head;
    // 尾节点
    listNode *tail;
    // 链表长度，即链表所包含的节点数
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
</code></pre></div><p>通过list 结构可以很方便地取到链表的头节点、尾节点以及链表长度。dup 、 free 和 match 属性是用于实现多态链表所需的类型特定函数，具体地，dup 函数用于复制链表节点所保存的值；free 函数用于释放链表节点所保存的值；match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。使用list之后的链表结构如下：</p>
<figure><img src="http://zzk31.320.io/img/20230521172758.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： listNode有 prev 和 next 指针， 可以以$O(1)$的时间复杂度获取某个节点的前置节点和后置节点</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都为 NULL ， 对链表的访问以 NULL 为终点</li>
<li>带表头指针和表尾指针： 通过 list的 head 指针和 tail 指针可以很容易获取表头结点和表尾节点</li>
<li>$O(1)$时间复杂度获取链表长度：list 的len 属性来记录了链表节点</li>
<li>多态： listNode使用 void* 指针来保存节点值， 并且可以通过 list 的 dup 、free 、match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值并且应用不同的复制函数、内存释放函数和匹配函数。</li>
</ul>
<h2>三、list中一些函数的源码实现</h2>
<ol>
<li>将元素插入到list表头，如下图所示，向表头插入val0之后list的变化，红色的相关指针是发生变化的指针。</li>
</ol>
<figure><img src="http://zzk31.320.io/img/20230521230420.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>/*
 * 使用给定的value值构造新的节点并添加到链表的表头
 * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL
 * 如果执行成功，返回传入的链表指针
 * T = O(1)
 */
list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    // 为节点分配内存
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;

    // 保存值指针
    node-&gt;value = value;

    // 添加节点到空链表
    // 当链表为空时，新插入的节点既是头结点也是尾结点
    if (list-&gt;len == 0) {
        list-&gt;head = list-&gt;tail = node;
        // 注意头结点的前驱指针应该为空，尾结点的后继指针应该为空
        node-&gt;prev = node-&gt;next = NULL;
    // 添加节点到非空链表
    // 当链表非空时,采用头插法将新插入节点链接到链表头部,并更新list的head指针
    } else {
        node-&gt;prev = NULL; //注意头结点的前驱指针应该为空
        node-&gt;next = list-&gt;head;
        list-&gt;head-&gt;prev = node;
        list-&gt;head = node;
    }

    // 更新链表节点数
    list-&gt;len++;

    return list;
}
</code></pre></div><ol start="2">
<li>将元素插入到list表尾，如下图所示，想表尾插入val5之后list的变化，红色的相关指针是发生变化的指针。</li>
</ol>
<figure><img src="http://zzk31.320.io/img/20230521230452.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>/*
 * 使用给定的value值构造新的节点并添加到链表的表尾
 * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL
 * 如果执行成功，返回传入的链表指针
 * T = O(1)
 */
list *listAddNodeTail(list *list, void *value)
{
    listNode *node;

    // 为新节点分配内存
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;

    // 保存值指针
    node-&gt;value = value;

    // 目标链表为空
    // 当链表为空时，新插入的节点既是头结点也是尾结点
    if (list-&gt;len == 0) {
        list-&gt;head = list-&gt;tail = node;
        // 注意头结点的前驱指针应该为空，尾结点的后继指针应该为空
        node-&gt;prev = node-&gt;next = NULL;
    // 目标链表非空
    } else {
        node-&gt;prev = list-&gt;tail;
        node-&gt;next = NULL;
        list-&gt;tail-&gt;next = node;
        list-&gt;tail = node;
    }

    // 更新链表节点数
    list-&gt;len++;

    return list;
}
</code></pre></div><ol start="3">
<li>创建list，如下图所示，其中NULL指针没有画出：</li>
</ol>
<figure><img src="http://zzk31.320.io/img/20230521230555.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>/*
 * 创建一个新的链表
 * 创建成功返回链表，失败返回 NULL 。
 * T = O(1)
 */
list *listCreate(void)
{
    struct list *list;

    // 分配内存
    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;

    // 初始化各项属性
    list-&gt;head = list-&gt;tail = NULL;
    list-&gt;len = 0;
    list-&gt;dup = NULL;
    list-&gt;free = NULL;
    list-&gt;match = NULL;

    return list;
}
</code></pre></div>]]></content:encoded>
      <enclosure url="http://zzk31.320.io/img/20230521171907.png" type="image/png"/>
    </item>
    <item>
      <title>Redis学习笔记之字符串</title>
      <link>https://shzyjbr.github.com/person-database/person-database/middleware/redis/redis-learn-string.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/middleware/redis/redis-learn-string.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">Redis学习笔记之字符串</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 本系列是个人的Redis学习笔记，参考的书籍有《Redis设计与实现》、《Redis深度历险--核心原理与应用实践》，Redis源码版本是黄健宏老师注释的Redis-3.0-annotated版本 一、SDS基本概念介绍 Redis有五种基础数据结构，分别是s...</description>
      <category>中间件</category>
      <pubDate>Thu, 12 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<blockquote>
<p>本系列是个人的Redis学习笔记，参考的书籍有《Redis设计与实现》、《Redis深度历险--核心原理与应用实践》，Redis源码版本是黄健宏老师注释的<a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener noreferrer">Redis-3.0-annotated</a>版本</p>
</blockquote>
<h2>一、SDS基本概念介绍</h2>
<p>Redis有五种基础数据结构，分别是string（字符串）、list（列表）、hash（字典）、set（集合）以及zset（也叫做sorted set，有序集合）。其中，Redis中的字符串采用了一种名为简单动态字符串的类型（simple dynamic string, SDS），而不是C字符串（具体原因后续会解释）。在Redis中，C字符串仅作为字符串字面量，即类似<code>"Hello, world"</code>，而在需要使用可修改的字符串的地方，均采用SDS来表示字符串。</p>
<p>当客户端执行命令：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>redis&gt; SET name zzk
OK
</code></pre></div><p>Redis将在数据库中创建一个新的键值对。其中，键值对的key是一个SDS对象，其中包含着字符串"name"；value是一个SDS对象，内部包含着字符串“zzk”。</p>
<p>又如，当客户端执行如下命令：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>redis&gt; LPUSH classmates xiaoming xiaohong xiaobai
</code></pre></div><p>Redis将在数据库中创建一个键值对，其中，key是一个包含着字符串"classmates"的SDS对象，value是一个list对象。这个list对象有三个元素，每个元素都是一个SDS对象，第一个SDS对象包含字符串"xiaoming"，第二个SDS对象包含字符串"xiaohong"等。</p>
<p>从上述例子可以看出，SDS作为Redis的字符串实现，被频繁用在各种使用场景。</p>
<h2>二、为什么使用SDS而不是C字符串？</h2>
<blockquote>
<p>以下涉及的Redis代码来自Redis3.0，虽然Redis目前已经更新到7.0，但是数据结构的实现原理是一脉相承的，3.0版本的代码更加简单，有助于原理的理解。</p>
</blockquote>
<p>SDS的结构定义如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>struct sdshdr {

    int len;
    
    int free;
    
    char buf[];

};
</code></pre></div><p>其中，buf是一个字符数组，用于保存字符串；len用于记录buf数组中已使用字节的数量，也就是SDS所保存的字符串的长度；free用于记录buf数组中未使用字节的数量。</p>
<p>下图表示一个包含字符串“zzk”的SDS对象。</p>
<figure><img src="http://zzk31.320.io/img/20230521135841.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个SDS对象中，buf是一个char数组，其数组内容为:'z'，'z'，'k'和末尾的'\0'。free为0表示没有多余的字节可供使用，len为3表示这个SDS的字符串长度为3（与C字符串长度定义一样，不包括末尾的'\0'）</p>
<p>下图展示了另一个SDS对象的内部结构：</p>
<figure><img src="http://zzk31.320.io/img/20230521135902.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个SDS对象中，buf数组的内容为"sea"(末尾还有个'\0')，len为3表示这个SDS的字符串长度为3，而free为3表示这个buf数组还有3个字节未被使用。</p>
<h3>1. 常数时间获取字符串长度</h3>
<p>从上述两个例子可以看出，buf数组的实际大小并不总是等于（字符串长度+1）。</p>
<p>而在C语言中，一个C字符串例子如下：</p>
<figure><img src="http://zzk31.320.io/img/20230521135922.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看出，C字符串并不包含长度信息，当需要获取字符串长度信息时，需要遍历一遍字符串才能计算出其长度，时间复杂度为$O(n) $,n为字符串长度。（题外话：strlen()是求C字符串长度函数，有时候编程不注意，还可能将strlen()写到循环判断条件中，造成复杂度提升一个量级）</p>
<p>因此，追求效率的Redis并没有直接采用C字符串作为字符串实现，而是使用了len来记录当前使用的字符大小，从而将时间复杂度降低到$O(1)$。</p>
<h3>2. 防止缓冲区溢出</h3>
<p>如果使用不当，C字符串还可能带来缓冲区溢出的问题。</p>
<p>假设如下情况，有两个C字符串s1和s2，他们的空间分配位置如下，s2紧挨在s1后面。</p>
<figure><img src="http://zzk31.320.io/img/20230521140010.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>若直接调用C函数strcat(s1, ",Lucy")，企图将s1的内容修改为"Hey,Lucy"，这样做确实能达到目的。然而，这种方式是错误的，正确的方式应该是在调用strcat()之前为s1分配足够的空间，而不是不经检查地直接调用。因为这种方式会导致s2被覆盖，称之为缓冲区溢出现象，如下图所示：</p>
<figure><img src="http://zzk31.320.io/img/20230521135953.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>而SDS的设计则避免了这一情况。当需要对SDS进行扩充时，SDS中的free属性使得SDS的API很容易检查SDS的剩余空间是否满足修改的需要，如果不满足的话，会为SDS分配一个新的容量足够的buf数组，再去执行修改操作。因此，SDS的使用者不需要手动修改SDS空间大小，也不用担心出现缓冲区溢出问题。</p>
<h3>3. 提高内存重分配效率</h3>
<p>如前所述，C字符串本身并不保存自身的长度信息，而是通过在字符串末尾添加一个'\0'来标识字符串结束。因此，对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符用于保存'\0'字符）。</p>
<p>这种关联性使得对C字符串的增加或者删除字符操作总是伴随着内存重分配操作。</p>
<p>仍以C字符串的拼接场景为例，若要在值为“hello”的字符串s1后面拼接上“,world”，那么在调用<code>strcat(s1,",world");</code>操作之前，需要先为s1分配足够大的空间，否则就会发生缓冲区溢出。</p>
<p>若之后我们想在s1之后在拼接上"!!!"，那么在调用<code>strcat(s1,"!!!");</code>操作之前又需要为s1分配空间。</p>
<p>这种频繁分配空间的方式会带来性能开销，而Redis作为高性能的缓冲中间件，若是采用这种方式则必然对性能造成影响。</p>
<p>因此，SDS采用了空间预分配方式来解决这一问题。在 SDS 中， buf 数组的长度不一定就是实际存储的字符数量加一， 数组里面可以包含未使用的字节， 而SDS 的 free 属性记录了这些字节的数量 。</p>
<h3>4.SDS的空间预分配策略</h3>
<p>空间预分配策略用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p>
<p>其中， 额外分配的未使用空间数量由以下规则决定：</p>
<ul>
<li>如果对 SDS 进行修改之后， SDS 的长度 len 小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 10 字节， 那么程序也会分配13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 10+ 10 + 1 = 21 字节（额外的一字节用于保存'\0'字符）</li>
<li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 10 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 10 MB + 1 MB + 1 byte 。</li>
</ul>
<p>第一条规则简单地说就是成倍增长规则，只不过这个基数是修改之后的长度。第二条规则是因为Redis需要在性能和效率之间取舍，如果达到了1MB的级别还是采用成倍增长规则，那么SDS的增长速度很快导致大量的内存空间占用。</p>
<p>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。</p>
<p><strong>此外，SDS还采用了惰性空间释放方式。</strong></p>
<p>所谓惰性空间释放是指， 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。也就是说，惰性空间释放用于优化 SDS 的字符串缩短操作。</p>
<p>例如， sdstrim 函数接受一个 SDS 和一个 C字符串作为参数， 从 SDS 左右两端分别移除所有在 C字符串中出现过的字符。</p>
<p>执行<code>sdstrim(s, "AA..");</code>后SDS的结构变化如下图所示：</p>
<figure><img src="http://zzk31.320.io/img/20230521140039.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到，并没有回收三个'A'字符所占的空间，而是使用free记录了剩余空间。</p>
<p>当在下一次对SDS进行修改操作，比如调用<code>strcat(s, "zzk")</code>时，不必在进行内存重分配，因为有足够的剩余空间支持拼接操作，结果如下所示：</p>
<figure><img src="http://zzk31.320.io/img/20230521134208.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3>5.二进制安全</h3>
<p>此外，在C字符串中，由于只使用'\0'来表示字符串结束，因此，一个字符串里面不能包含空字符，否则就会被认为是字符串结尾。这就使得C字符串只能存储文本数据，而不能存储二进制数据如图片、视频等。</p>
<p>而Redis的SDS则可以用来存储二进制数据，SDS不靠空字符来标识存储内容的结束，而是通过len来标识。buf[]数组是一个char数据，可以直接用于存储二进制数据（只需要定义好编解码格式即可进行读写）。</p>
<p>当然，另一方面，SDS也会在字符串末尾添加'\0'，因此SDS也可以复用部分C字符串函数。</p>
]]></content:encoded>
      <enclosure url="http://zzk31.320.io/img/20230521135841.png" type="image/png"/>
    </item>
    <item>
      <title>hexo搭建个人博客+NexT主题</title>
      <link>https://shzyjbr.github.com/person-database/person-database/blog/hexo-next.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/blog/hexo-next.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">hexo搭建个人博客+NexT主题</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 1 hexo简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，生成静态网页。 --Hexo官网 2 hexo安装 安装hexo需要先安装node.js和Git 2.1 安装node.js Node.j...</description>
      <pubDate>Fri, 27 Nov 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h3>1 hexo简介</h3>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener noreferrer">Markdown</a>（或其他渲染引擎）解析文章，生成静态网页。   --<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener noreferrer">Hexo</a>官网</p>
</blockquote>
<h3>2 hexo安装</h3>
<p>安装hexo需要先安装node.js和Git</p>
<h4>2.1 安装node.js</h4>
<blockquote>
<p>Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</p>
</blockquote>
<p>通过node.js官网下载安装版进行安装，选择14.15.1长期支持版 官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js</a></p>
<figure><img src="https://i.loli.net/2020/11/27/Eym3zR8bX1FpcxT.png" alt="image-20201127135412872.png" tabindex="0" loading="lazy"><figcaption>image-20201127135412872.png</figcaption></figure>
<p>安装过程与普通软件安装没有差别，一路next。</p>
<h4>2.2 安装Git</h4>
<p>通过Git官网下载Git安装版进行安装，安装版本2.29.2 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git (git-scm.com)</a></p>
<figure><img src="https://i.loli.net/2020/11/27/Dew6M4naP5Aucby.png" alt="git.png" tabindex="0" loading="lazy"><figcaption>git.png</figcaption></figure>
<h4>2.3 正式安装hexo</h4>
<p>安装好node.js和Git之后就可以开始进行hexo的安装</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>npm install -g hexo-cli
</code></pre></div><p>安装成功之后可以在cmd命令行中输入hexo，查看是否安装成功</p>
<figure><img src="https://i.loli.net/2020/11/27/P4Mktm3IlERVxoC.png" alt="image-20201127140007483" tabindex="0" loading="lazy"><figcaption>image-20201127140007483</figcaption></figure>
<p>出现如下提示则表示安装成功。</p>
<h3>3 使用hexo搭建博客</h3>
<h4>3.1 初始化</h4>
<p>在Windows中创建一个文件夹，作为想要搭建的博客的根目录，比如我的就是 D:\blog\hexo</p>
<p><strong>在cmd中进入根目录下</strong>，使用如下命令初始化，该命令会在根目录下创建hexo所需的文件</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>hexo init
</code></pre></div><p>创建完成之后的目录如下所示：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre></div><p>其中_config.yml称为站点配置文件，对应的，themes/_config.yml称为主题配置文件。
简单解释下两个配置文件。根目录下的_config.yml是对整个博客站点的内容进行设置。hexo的博客可以指定多种主题，主题的配置是通过themes/_config.yml进行设置的。</p>
<h4>3.2 启动hexo</h4>
<p>使用如下命令可以启动hexo，进行快速效果预览。</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>hexo server
</code></pre></div><p>可以看到出现如下提示：</p>
<p><img src="https://i.loli.net/2020/11/27/qUmerCBi3Wcf6aF.png" alt="image-20201127141157314.png" loading="lazy">)</p>
<p>浏览器访问localhost:4000可以看到博客搭建成功。</p>
<figure><img src="https://i.loli.net/2020/11/27/w5hLyImDjSJio1k.png" alt="image-20201127141428928.png" tabindex="0" loading="lazy"><figcaption>image-20201127141428928.png</figcaption></figure>
<h3>4. 使用NexT主题</h3>
<p>hexo可以通过指定不同的主题，达到更换博客风格的目的。hexo的主题可以访问<a href="https://hexo.io/themes/" target="_blank" rel="noopener noreferrer">Themes | Hexo</a></p>
<p>本次选用Text主题。</p>
<h4>4.1 下载NexT主题</h4>
<p>我们通过Git来下载。</p>
<p><strong>在cmd目录下进入根目录</strong>，使用如下命令。</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre></div><p>下载完毕后可以看到themes目录下多了一个next文件夹</p>
<p><em>hexo把所有的主题都放在了themes文件夹里面，所以通常的做法就是把想要使用的主题放到在themes目录下面，之后去站点配置文件里面进行主题的设置。</em></p>
<h4>4.2 设置站点配置文件，进行主题更换</h4>
<p>打开站点配置文件_config.yml,  可以使用查找功能定位到themes关键字，修改为如下：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>theme: next
</code></pre></div><h4>4.3 启动博客进行验证</h4>
<p>输入<code>hexo server</code>启动博客，可以看到主题已经更换为NexT主题。</p>
<p><em>下图的NexT主题经过了其他设置，所以你的主题可能和我看起来有点不一样</em></p>
<figure><img src="https://i.loli.net/2020/11/27/TO42oeM7bp8xQ6y.png" alt="image-20201127145135433.png" tabindex="0" loading="lazy"><figcaption>image-20201127145135433.png</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://i.loli.net/2020/11/27/Eym3zR8bX1FpcxT.png" type="image/png"/>
    </item>
    <item>
      <title>logback自定义日志格式，以json格式为例</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/logback-custom-log-formattion.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/logback-custom-log-formattion.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">logback自定义日志格式，以json格式为例</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 【后端开发】logback自定义日志格式，以json格式为例 一、背景 在项目开发中，我们有时候会遇到需要指定日志格式的场景，比如项目的日志接入了在线日志收集系统，该收集系统要求日志需要满足其指定的日志格式才会被收集。 接下来，我就以打印json格式的日志为例...</description>
      <pubDate>Tue, 12 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>【后端开发】logback自定义日志格式，以json格式为例</h1>
<h2>一、背景</h2>
<p>在项目开发中，我们有时候会遇到需要指定日志格式的场景，比如项目的日志接入了在线日志收集系统，该收集系统要求日志需要满足其指定的日志格式才会被收集。</p>
<p>接下来，我就以打印json格式的日志为例，向各位分享两种方案。</p>
<h2>二、方案</h2>
<h3>2.1 方案1</h3>
<p>通过指定encoder的具体类为net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder类，在pattern中可以打印指定格式的日志。</p>
<p>pattern中的变量格式有三类。一类是logback自定义的诸如%level等，一类是如${app_name}这样我们定义在logback.xml中的properties。还有一类形如%X{variable_name}是通过在代码中设置进MDC变量的，关于MDC的使用本文就不展开了，感兴趣请自行搜索。</p>
<p>直接show出可用的logback配置代码，下面是一个appender的示例代码</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>your-appender-name<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>File</span><span class="token punctuation">&gt;</span></span>${log_path}/${app_name}-${currentTime}.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>File</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>append</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>append</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${log_path}/${app_name}-%d{yyyyMMdd}-%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>${logback.file.maxHistory}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>${logback.file.maxFileSize}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>totalSizeCap</span><span class="token punctuation">&gt;</span></span>${logback.file.totalSizeCap}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>totalSizeCap</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        
        <span class="token comment">&lt;!-- 打印json格式，请重点看这里--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>providers</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>
                         <span class="token comment">&lt;!--下面定义出一个json格式的消息，仅做示例--&gt;</span>
                        <span class="token comment">&lt;!--具体的信息格式请根据你的需求而定--&gt;</span>
                        {
                        "app_name": "${app_name}_info",
                        "level": "%level",
                        "log_time": "%date{\"yyyy-MM-dd HH:mm:ss.SSS\"}",
                        <span class="token comment">&lt;!--   "logger": "%logger",  %logger打印logger名字， %class打印具体类名--&gt;</span>
                        "logger": "%class",
                        "transaction_id": "%X{transaction_id}",
                        "address": "%X{address}",
                        "response_headers": "%X{response_headers}",
                        "response_payload": "%X{response_payload}",
                        "response_code": "%X{response_code}"
                        }
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>providers</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><h3>2.2 方案2</h3>
<p>另一种打印自定义格式的方法则是通过代码处理。</p>
<ol>
<li>首先，继承<code>ch.qos.logback.core.LayoutBase&lt;ILoggingEvent&gt;</code>，并重写doLayout(ILoggingEvent event)方法</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramLayout</span> <span class="token keyword">extends</span> <span class="token class-name">LayoutBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ILoggingEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 也可以自定义参数，后续可以在logback.xml中传入</span>
    <span class="token keyword">protected</span> <span class="token class-name">String</span> appName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ProgramLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 覆盖该方法，可以定制需要的日志格式
     * <span class="token keyword">@param</span> <span class="token parameter">event</span> The event to format
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">doLayout</span><span class="token punctuation">(</span><span class="token class-name">ILoggingEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ProgramLogParam</span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgramLogParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setApp_name</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>appName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLogger</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getLoggerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLog_time</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Timestamp</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getTimeStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setTransaction_id</span><span class="token punctuation">(</span><span class="token class-name">MDCUtil</span><span class="token punctuation">.</span><span class="token function">getTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过event.getFormattedMessage()就可以获取到源消息</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getFormattedMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getThrowableProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ExtendedThrowableProxyConverter</span> throwableConverter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExtendedThrowableProxyConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            throwableConverter<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getFormattedMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> throwableConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
            throwableConverter<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

		<span class="token comment">// 如果打印的源日志消息就包含json格式的字符串，则截取该部分消息作为code_message</span>
        <span class="token keyword">int</span> beginIndex <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"{"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> endIndex <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"}"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> jsonMsg <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>beginIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            params<span class="token punctuation">.</span><span class="token function">setCode_message</span><span class="token punctuation">(</span>jsonMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            params<span class="token punctuation">.</span><span class="token function">setCode_message</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">CoreConstants</span><span class="token punctuation">.</span><span class="token constant">LINE_SEPARATOR</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ProgramLogParam是个bean，我简单放一下，用了lombok的注解，方便查看</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramLogParam</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> app_name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> level<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> logger<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> log_time<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> code_message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> transaction_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2">
<li>在logback.xml在配置encoder的layout为该ProgramLayout，即可达到打印指定日志格式的目的。</li>
</ol>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}_info-info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--日志文档输出格式--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.encoder.LayoutWrappingEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.demo.log.layout.TransactionLayout<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">&lt;!--传入自定义参数--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appName</span><span class="token punctuation">&gt;</span></span>${APP_NAME}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appName</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>1024MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>zzk的个人知识库</title>
      <link>https://shzyjbr.github.com/person-database/person-database/home.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/home.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">zzk的个人知识库</source>
      <description>拉个 Star 如果本知识库的内容帮助到你，还请点个免费的 Star，感谢。传送门：GitHub 开发 Redis 操作系统 设计模式 博客</description>
      <pubDate>Thu, 07 Mar 2024 09:41:42 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个 Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的 Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h2>开发</h2>
<ul>
<li><a href="/person-database/java/dif-between-transactionlog-and-programlog.html" target="_blank">项目日志建设之流水日志和程序日志的区分</a></li>
<li><a href="/person-database/java/logback-custom-log-formattion.html" target="_blank">logback 自定义日志格式，以 json 格式为例</a></li>
<li><a href="/person-database/java/distributed-lock-introduction.html" target="_blank">分布式锁理论介绍</a></li>
</ul>
<h2>Redis</h2>
<ul>
<li><a href="/person-database/middleware/redis/redis-learn-string.html" target="_blank">Redis 学习笔记之字符串</a></li>
<li><a href="/person-database/middleware/redis/redis-learn-list.html" target="_blank">Redis 学习笔记之链表</a></li>
</ul>
<h2>操作系统</h2>
<ul>
<li><a href="/person-database/java/deadlock.html" target="_blank">关于死锁的一点笔记</a></li>
</ul>
<h2>设计模式</h2>
<ul>
<li><a href="/person-database/java/about-singleton-pattern.html" target="_blank">浅谈单例模式</a></li>
</ul>
<h2>博客</h2>
<ul>
<li><a href="/person-database/blog/hexo-next.html" target="_blank">hexo 搭建个人博客+NexT 主题</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍页</title>
      <link>https://shzyjbr.github.com/person-database/person-database/intro.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/intro.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">介绍页</source>
      <description>介绍页 问渠哪得清如许，为有源头活水来。一个普通的后端程序员。</description>
      <pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>问渠哪得清如许，为有源头活水来。一个普通的后端程序员。</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于作者</title>
      <link>https://shzyjbr.github.com/person-database/person-database/about-the-author/self-introduction.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/about-the-author/self-introduction.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">关于作者</source>
      <description>23届双非硕，一个小小的后端程序员。</description>
      <pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>23届双非硕，一个小小的后端程序员。</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目日志建设之流水日志和程序日志的区分</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/dif-between-transactionlog-and-programlog.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/dif-between-transactionlog-and-programlog.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">项目日志建设之流水日志和程序日志的区分</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 项目日志建设之流水日志和程序日志的区分 最近项目要求对程序日志进行两类区分，将日志大体记录为流水日志和程序日志。 所谓流水日志，更详细的说是请求响应流水日志，记录的是系统执行的web请求、响应的内容。其主要方面一般包括后端接口调用、后端调用其他服务接口的请求与...</description>
      <category>项目实践</category>
      <pubDate>Fri, 08 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>项目日志建设之流水日志和程序日志的区分</h1>
<p>最近项目要求对程序日志进行两类区分，将日志大体记录为流水日志和程序日志。</p>
<p>所谓流水日志，更详细的说是请求响应流水日志，记录的是系统执行的web请求、响应的内容。其主要方面一般包括后端接口调用、后端调用其他服务接口的请求与响应日志。如果项目有对外向其他系统暴露服务，那么还需要包括其他服务调用本系统接口的请求响应日志。</p>
<p>而程序日志则是我们原来熟知的在程序中记录的一些常规日志，如记录异常请求处理、运行中一些助于排查的信息记录等，可以说是除了流水日志外的其他日志。</p>
<p>另一方面，在区分流水日志和程序日志的基础上，还希望将debug、info、warn、error等不同级别的日志写入不同的日志文件中，方便查看。</p>
<h2>如何去做这样的一个日志区分呢？</h2>
<p>在动手编写日志配置文件之前，我们可以大概设想一下我们需要的日志文件结构。举个例子，按照以上要求，对于流水日志，我们需要内容为流水类型且日志级别为info的日志文件，..., 内容为流水类型且日志级别为error的日志文件。为方便后续描述，我们可以将流水用transaction表示，程序用program表示。日志命名格式上，我们可以采用<code>项目名_日志类型-日志级别-日期.log</code>来命名。举个例子，有一个项目名为xxx-gateway，那么这个项目在2023年8月29日这天的info级别的流水日志，可以命名为<code>xxx-gateway_transaction-info-2023-08-29.log</code>，同理还有<code>xxx-gateway_transaction-debug-2023-08-29.log</code>、<code>xxx-gateway_transaction-warn-2023-08-29.log</code>和<code>xxx-gateway_transaction-error-2023-08-29.log</code>。对于程序日志则有<code>xxx-gateway_program-info-2023-08-29.log</code>、<code>xxx-gateway_program-warn-2023-08-29.log</code>等，其他不再列举。
总结一下，假设日志目录为logs，文件结构如下:</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>-logs
    - xxx-gateway_transaction-debug-2023-08-29.log
    - xxx-gateway_transaction-info-2023-08-29.log
    - xxx-gateway_transaction-warn-2023-08-29.log
    - xxx-gateway_transaction-error-2023-08-29.log
    - xxx-gateway_program-error-2023-08-29.log
    - xxx-gateway_program-info-2023-08-29.log
    - xxx-gateway_program-warn-2023-08-29.log
    - xxx-gateway_program-error-2023-08-29.log
</code></pre></div><p>本文采用的日志框架是logback，在Spring Boot项目中搭配使用。</p>
<h2>具体做法</h2>
<h3>1. 定义appender</h3>
<p>根据以上思路，我们需要在logback配置文件（本文是logback-spring.xml）中配置八个appender来实现向上述八个不同日志文件写入不同日志级别的日志记录。</p>
<p>以写入<code>xxx-gateway_transaction-info-2023-08-29.log</code>的appender为例，我们拆解一下这样一个appender需要什么配置，相关的注释我都标注在代码上了</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}_transaction-info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--日志文档输出格式--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.encoder.LayoutWrappingEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.gateway.log.layout.TransactionLayout<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appName</span><span class="token punctuation">&gt;</span></span>${APP_NAME}_info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appName</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 设置字符集 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}-info-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>1024MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!--日志文档保留天数--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 此日志文档只记录info级别的 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>&lt;appender&gt;</code>:我将这个appender命名为TRANSACTION_INFO_FILE，表示它是用来写入请求响应流水日志且为info级别的日志文件。class选择logback提供的一个类，该类可以进行日志文件的滚动更新。所谓滚动更新用大白话解释就是，怎么分割归档文件。主要看<code>&lt;rollingPolicy&gt;</code>中的配置,当前例子是%d{yyyy-MM-dd}，也就是按不同的日期进行归档（%i作用是当文件大小太大则按1024MB分割出文件进行标号）</p>
<p><code>&lt;File&gt;</code>标签中的${LOG_HOME}这些都是自定义的变量，比如我的项目的LOG_HOME就是logs，${APP_NAME}就是项目名称，比如在这里就是xxx-gateway，因此组合起来的文件命名格式就是上文描述的格式。</p>
<p><code>&lt;encoder&gt;</code>用来自定义一条日志打印的具体格式，在这里不再展开，这里有我写的一篇关于自定义日志格式的文章:<a href="./logback-custom-log-formattion" target="blank">logback自定义日志格式，以json格式为例</a>，可以参考。</p>
<p><code>&lt;rollingPolicy&gt;</code>标签使用到logback提供的TimeBasedRollingPolicy，这意味着日志文件将根据大小和时间限制进行滚动。<code>&lt;fileNamePattern&gt;</code>指定滚动的时候文件名的格式，<code>&lt;timeBasedFileNamingAndTriggeringPolicy&gt;</code>用于控制日志文件大小到达某一阈值需要进行切分。<code>&lt;maxHistory&gt;</code>用于控制归档的日志留存的时长，单位是天。</p>
<p><code>&lt;filter&gt;</code>表达的意义是这是一个只接受INFO级别日志事件的级别筛选器。对于任何非INFO级别的日志事件都将被拒绝。</p>
<p>因此，这个appender做的事情就是，定义了请求响应流水日志且日志级别为info的日志要输出到<code>${LOG_HOME}/${APP_NAME}_transaction-info.log</code>这个文件中。滚动策略是先根据日期将日志记录到不同的文件中，然后根据文件大小滚动每个日期的日志文件。这样可以实现按天滚动的基础上，再根据文件大小进行滚动的效果。日志布局也就是日志的打印格式通过com.xxx.gateway.log.layout.TransactionLayout进行自定义。</p>
<p>按照以上做法，我们可以依葫芦画瓢，定义出另外7个appender。</p>
<h3>2. 定义logger</h3>
<p>logger称作日志记录器，用于定义某一日志记录器的行为
以下面这个root记录器为例</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul>
<li>level: 指定root日志记录器的日志级别为"info"。这意味着root日志记录器将记录所有"info"级别及以上的日志消息，而低于"info"级别的消息将被忽略。注意！这里是info及以上！</li>
<li>additivity: 是否启用日志事件的传播。如果设置为"false"，则root日志记录器的日志消息将只被发送到指定的appender，并不会传播到其他日志记录器。如果设置为"true"，则日志消息将传播给其他适用的日志记录器，也就是一条日志被root日志记录器消费掉了，独占。</li>
<li>appender-ref: 引用了四个不同的appender，分别是"PROGRAM_INFO_FILE"、"PROGRAM_WARN_FILE"、"PROGRAM_ERROR_FILE"和"STDOUT"。这些引用定义了将日志消息发送到哪些appender进行记录。也就是一条消息会被发往这四个appender,这些appender会根据自己的配置去决定是否记录该日志。</li>
</ul>
<p>以上这个日志记录器就可以作为我们项目中的程序日志记录器，通常我们在类中通过<code>private static Logger log = org.slf4j.LoggerFactory.getLogger(AnyExample.class);</code>定义出来的log对象就会使用到这个日志记录器，包括使用@Slf4j注解也一样。</p>
<p>而针对流水日志记录器，配置如下：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>web_transaction_logger<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>该logger 多了一个名字，也就是"web_transaction_logger"。在代码中，当我们需要记录流水日志时，我们需要这样引用该logger:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> transactionlogger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"web_transaction_logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过这种方式，我们将程序日志和流水日志进行了区分。
这种配置的一个好处是可以无侵入地在旧有项目上对程序日志和流水日志进行区分。原先代码中打日志的地方，我们都可以不做改动，默认作为程序日志，而针对web请求响应，我们可以在诸如filter等地方使用web_transaction_logger进行记录。</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于分享内容</title>
      <link>https://shzyjbr.github.com/person-database/person-database/life/comeon.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/life/comeon.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">关于分享内容</source>
      <description>分享内容 生活分享的内容写在这里</description>
      <pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>分享内容</h2>
<p>生活分享的内容写在这里</p>
]]></content:encoded>
    </item>
  </channel>
</rss>