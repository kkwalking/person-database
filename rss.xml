<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://shzyjbr.github.com/person-database/person-database/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://shzyjbr.github.com/person-database/person-database/rss.xml" rel="self" type="application/rss+xml"/>
    <title>zzk的个人知识库</title>
    <link>https://shzyjbr.github.com/person-database/person-database/</link>
    <description>欢迎来到zzk的个人知识库</description>
    <language>zh-CN</language>
    <pubDate>Tue, 12 Mar 2024 07:14:30 GMT</pubDate>
    <lastBuildDate>Tue, 12 Mar 2024 07:14:30 GMT</lastBuildDate>
    <generator>@vuepress/plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>个人</category>
    <category>项目实践</category>
    <item>
      <title>【后端开发】logback自定义日志格式，以json格式为例</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/logback-custom-log-formattion.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/logback-custom-log-formattion.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">【后端开发】logback自定义日志格式，以json格式为例</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 【后端开发】logback自定义日志格式，以json格式为例 一、背景 在项目开发中，我们有时候会遇到需要指定日志格式的场景，比如项目的日志接入了在线日志收集系统，该收集系统要求日志需要满足其指定的日志格式才会被收集。 接下来，我就以打印json格式的日志为例...</description>
      <pubDate>Tue, 12 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>【后端开发】logback自定义日志格式，以json格式为例</h1>
<h2>一、背景</h2>
<p>在项目开发中，我们有时候会遇到需要指定日志格式的场景，比如项目的日志接入了在线日志收集系统，该收集系统要求日志需要满足其指定的日志格式才会被收集。</p>
<p>接下来，我就以打印json格式的日志为例，向各位分享两种方案。</p>
<h2>二、方案</h2>
<h3>2.1 方案1</h3>
<p>通过指定encoder的具体类为net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder类，在pattern中可以打印指定格式的日志。</p>
<p>pattern中的变量格式有三类。一类是logback自定义的诸如%level等，一类是如${app_name}这样我们定义在logback.xml中的properties。还有一类形如%X{variable_name}是通过在代码中设置进MDC变量的，关于MDC的使用本文就不展开了，感兴趣请自行搜索。</p>
<p>直接show出可用的logback配置代码，下面是一个appender的示例代码</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>your-appender-name<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>File</span><span class="token punctuation">&gt;</span></span>${log_path}/${app_name}-${currentTime}.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>File</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>append</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>append</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${log_path}/${app_name}-%d{yyyyMMdd}-%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>${logback.file.maxHistory}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>${logback.file.maxFileSize}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>totalSizeCap</span><span class="token punctuation">&gt;</span></span>${logback.file.totalSizeCap}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>totalSizeCap</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        
        <span class="token comment">&lt;!-- 打印json格式，请重点看这里--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>providers</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>
                         <span class="token comment">&lt;!--下面定义出一个json格式的消息，仅做示例--&gt;</span>
                        <span class="token comment">&lt;!--具体的信息格式请根据你的需求而定--&gt;</span>
                        {
                        "app_name": "${app_name}_info",
                        "level": "%level",
                        "log_time": "%date{\"yyyy-MM-dd HH:mm:ss.SSS\"}",
                        <span class="token comment">&lt;!--   "logger": "%logger",  %logger打印logger名字， %class打印具体类名--&gt;</span>
                        "logger": "%class",
                        "transaction_id": "%X{transaction_id}",
                        "address": "%X{address}",
                        "response_headers": "%X{response_headers}",
                        "response_payload": "%X{response_payload}",
                        "response_code": "%X{response_code}"
                        }
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>providers</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><h3>2.2 方案2</h3>
<p>另一种打印自定义格式的方法则是通过代码处理。</p>
<ol>
<li>首先，继承<code>ch.qos.logback.core.LayoutBase&lt;ILoggingEvent&gt;</code>，并重写doLayout(ILoggingEvent event)方法</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramLayout</span> <span class="token keyword">extends</span> <span class="token class-name">LayoutBase</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ILoggingEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 也可以自定义参数，后续可以在logback.xml中传入</span>
    <span class="token keyword">protected</span> <span class="token class-name">String</span> appName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ProgramLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 覆盖该方法，可以定制需要的日志格式
     * <span class="token keyword">@param</span> <span class="token parameter">event</span> The event to format
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">doLayout</span><span class="token punctuation">(</span><span class="token class-name">ILoggingEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ProgramLogParam</span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgramLogParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setApp_name</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>appName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLogger</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getLoggerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setLog_time</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Timestamp</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getTimeStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        params<span class="token punctuation">.</span><span class="token function">setTransaction_id</span><span class="token punctuation">(</span><span class="token class-name">MDCUtil</span><span class="token punctuation">.</span><span class="token function">getTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过event.getFormattedMessage()就可以获取到源消息</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getFormattedMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getThrowableProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ExtendedThrowableProxyConverter</span> throwableConverter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExtendedThrowableProxyConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            throwableConverter<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getFormattedMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> throwableConverter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
            throwableConverter<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

		<span class="token comment">// 如果打印的源日志消息就包含json格式的字符串，则截取该部分消息作为code_message</span>
        <span class="token keyword">int</span> beginIndex <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"{"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> endIndex <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"}"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> jsonMsg <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>beginIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            params<span class="token punctuation">.</span><span class="token function">setCode_message</span><span class="token punctuation">(</span>jsonMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            params<span class="token punctuation">.</span><span class="token function">setCode_message</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">CoreConstants</span><span class="token punctuation">.</span><span class="token constant">LINE_SEPARATOR</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ProgramLogParam是个bean，我简单放一下，用了lombok的注解，方便查看</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProgramLogParam</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> app_name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> level<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> logger<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> log_time<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> code_message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> transaction_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2">
<li>在logback.xml在配置encoder的layout为该ProgramLayout，即可达到打印指定日志格式的目的。</li>
</ol>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}_info-info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--日志文档输出格式--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.encoder.LayoutWrappingEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.demo.log.layout.TransactionLayout<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">&lt;!--传入自定义参数--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appName</span><span class="token punctuation">&gt;</span></span>${APP_NAME}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appName</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>1024MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>zzk的个人知识库</title>
      <link>https://shzyjbr.github.com/person-database/person-database/home.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/home.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">zzk的个人知识库</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub Java</description>
      <pubDate>Thu, 07 Mar 2024 09:41:42 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h2>Java</h2>
<ul>
<li><a href="/person-database/java/about-singleton-pattern.html" target="_blank">浅谈单例模式</a></li>
<li><a href="/person-database/java/deadlock.html" target="_blank">关于死锁的一点笔记</a></li>
<li><a href="/person-database/java/dif-between-transactionlog-and-programlog.html" target="_blank">项目日志建设之流水日志和程序日志的区分</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍页</title>
      <link>https://shzyjbr.github.com/person-database/person-database/intro.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/intro.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">介绍页</source>
      <description>介绍页 问渠哪得清如许，为有源头活水来。一个普通的后端程序员。</description>
      <pubDate>Thu, 07 Mar 2024 09:41:42 GMT</pubDate>
      <content:encoded><![CDATA[
<p>问渠哪得清如许，为有源头活水来。一个普通的后端程序员。</p>
]]></content:encoded>
      <enclosure url="https://shzyjbr.github.com/person-database/person-database/assets/images/cover3.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>关于作者</title>
      <link>https://shzyjbr.github.com/person-database/person-database/about-the-author/self-introduction.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/about-the-author/self-introduction.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">关于作者</source>
      <description>23届双非硕，一个小小的后端程序员。</description>
      <category>个人</category>
      <pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>23届双非硕，一个小小的后端程序员。</p>
]]></content:encoded>
    </item>
    <item>
      <title>【设计模式】浅谈单例模式</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/about-singleton-pattern.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/about-singleton-pattern.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">【设计模式】浅谈单例模式</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 浅谈单例模式 饿汉模式 缺点：在需要初始化许多对象的时候会导致系统启动较慢，比如在有许多个单例对象的容器中，启动该容器的初始过程会比较长。 懒加载模式 缺点：同步方法锁住了对象，降低了系统的处理速度。 错误的双重锁检查 这样的写法是有问题的。在JVM中， in...</description>
      <pubDate>Fri, 10 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>浅谈单例模式</h1>
<h4>饿汉模式</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>缺点：在需要初始化许多对象的时候会导致系统启动较慢，比如在有许多个单例对象的容器中，启动该容器的初始过程会比较长。</p>
<h4>懒加载模式</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>缺点：同步方法锁住了对象，降低了系统的处理速度。</p>
<h4>错误的双重锁检查</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的写法是有问题的。在JVM中， instance = new Singleton(); 语句并不是一个原子操作，分为创建对象和引用赋值两步。其中，创建对象需要为对象分配空间，再进行初始化。以上三步，分配内存永远是第一步，但是后面两步则可能被重排序。</p>
<p>JVM并不保证初始化先于引用赋值的顺序，因此很可能是先创建了对象，即在Singleton实例分配了内存空间，但是还未进行初始化，然后赋值给了<code>instance</code>，这是实例虽然分配到了空间，但是其并未完成初始化，而<code>instance</code>引用却不为空，这时另一个线程抢占执行，执行了<code>getInstance（）</code>方法，便会发现<code>instance</code>不为<code>null</code>，从而直接返回了<code>instance</code>，导致系统出错。</p>
<h4>正确的双重锁检查</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用volatile的内存可见性可以使得<code>instance</code>不会被线程缓存，所有的线程读写该对象都需要对主内存进行操作。</p>
<p>volatile还可以防止指令重排序，从而使得上述的双重锁检查代码正确执行。这里的防止指令重排序是指，volatile修饰的<code>instance</code>对象，在执行代码 <code>instance = new Singleton()</code>时不会再被JVM进行指令重排序，会按照 <code>内存分配 -&gt; 初始化 -&gt; 引用赋值</code> 的顺序执行</p>
<h4>使用静态内部类</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonFactory</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//序列化方法  可忽略</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的写法利用了JVM的类加载机制，JVM在加载类的过程中确保了线程互斥，是线程安全的。外部类被加载时，不会立即加载内部类，从而<code>instance</code>不会立即被实例化。当<code>getInstance()</code> 第一次被调用时，内部类第一次被引用，从而加载了内部类，并完成了<code>instance</code>的实例化，而JVM的类加载机制确保了实例化instance的过程中的线程安全性。</p>
<p>缺点：使用静态内部类的方式，则存在传参的问题，外部无法传递参数给内部类</p>
<h4>使用枚举</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//其他方法代码</span>
<span class="token punctuation">}</span>
</code></pre></div><p>枚举类型的实例创建出来天然就是单例的，并且是线程安全的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>【操作系统】关于死锁的一点笔记</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/deadlock.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/deadlock.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">【操作系统】关于死锁的一点笔记</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 声明：以下内容均来自书籍《现代操作系统》，内容略有改动。 1.资源 死锁的产生与资源相关，因而先给出资源的定义：在进程对设备、文件等取得排他性访问权时，有可能会出现死锁，为便于讨论，把这类需要排他性使用的对象称为资源（resource）。资源可以是硬件设备（如...</description>
      <pubDate>Wed, 05 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<blockquote>
<p>声明：以下内容均来自书籍《现代操作系统》，内容略有改动。</p>
</blockquote>
<h3>1.资源</h3>
<p>死锁的产生与资源相关，因而先给出资源的定义：在进程对设备、文件等取得排他性访问权时，有可能会出现死锁，为便于讨论，把这类需要排他性使用的对象称为资源（resource）。资源可以是硬件设备（如打印机），或是一组信息（如数据库中一条加锁的记录）。简而言之，资源是随着时间的推移，必须能获得、使用和释放的任何东西。</p>
<p>资源又分为可抢占资源和不可抢占资源。</p>
<p>可抢占资源可以从拥有它的进程中被抢占而不会产生任何副作用，存储器就是一类可抢占的资源。操作系统可以把一个进程从内存中换出，换入另一个进程。</p>
<p>不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。例如，一个进程使用打印机来打印内容，突然将打印机分配给另一个进程导致打印内容混乱。因此打印机属于不可抢占资源。</p>
<p>总的来说，死锁与不可抢占资源有关。</p>
<h3>2.资源获取</h3>
<p>使用信号量来管理资源，down操作来获取资源，使用资源，up操作来释放资源。如下所示。</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>tydedef int semaphore;
semaphore resource_1;
void process_A(void) {
    down(&amp;resource_1);
    use(&amp;resource_1);
    up(&amp;resource_1);
}
</code></pre></div><p>通常，进程需要两个或更多的资源，它们可以顺序获取，如下所示</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>tydedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
</code></pre></div><p>现在考虑两个进程（A和B）以及两个资源的情况。</p>
<p>第一种方式如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>typedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
void process_B(void) {
   down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
</code></pre></div><p>第二种方式如下：</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>typedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void) {
    down(&amp;resource_1);
    down(&amp;resource_2);
    use_resources();
    up(&amp;resource_2);
    up(&amp;resource_1);
}
void process_B(void) {
    down(&amp;resource_2);
    down(&amp;resource_1);
    use_resources();
    up(&amp;resource_1);
    up(&amp;resource_2);
}
</code></pre></div><p>第一种方式中，两个进程以相同的次序请求资源，第二种方式中，两个进程请求资源的次序不同。这就可能造成不同的结果。</p>
<p>在第一种方式中，一个进程先于另一个进程获取资源，从而能够成功第二个资源并完成它的任务。如果另一个进程想在第一个资源被释放之前获取该资源，则会由于资源被加锁而被阻塞，直到该资源可用为止。然而在第二种方式中，则有产生死锁的风险。可能进程A获取了资源1，进程B获取了资源2，这时两个进程都想请求还未拥有的另一个资源，然而都会因此被阻塞，两个进程都无法继续运行。</p>
<h3>3.死锁</h3>
<p>死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
<p>死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源，但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以唤醒。进程的数量以及占有或者请求的资源数量和种类都是无关紧要的。这种死锁称为资源死锁（resource deadlock）。资源死锁很常见，但不是唯一类型。</p>
<h4>3.1 资源死锁的条件</h4>
<p>Coffman等人总结了发生资源死锁的四个必要条件：</p>
<ul>
<li>互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待条件。已经得到了某个资源的进程，可以再申请新的资源。</li>
<li>不可抢占条件。已经分配给某一个进程的资源，不能被强制性地抢占，它只能由占有它的进程显式地释放。</li>
<li>循环等待条件。死锁发生时，系统中一定有两个或以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</li>
</ul>
<p>有四种处理死锁的策略：</p>
<ul>
<li>忽略该问题。</li>
<li>检测死锁并从中恢复。</li>
<li>避免死锁。通过仔细对资源进行分配，可以动态地避免死锁。</li>
<li>防止死锁。通过破坏引起死锁的四个必要条件之一，防止死锁的产生。</li>
</ul>
<h4>3.2 死锁检测和死锁恢复</h4>
<p>使用这种技术的系统不试图阻止死锁的产生，而是允许死锁的发生，当检测到死锁发生后，采取措施进行恢复。</p>
<h5>3.2.1 每种类型一个资源的死锁检测</h5>
<p>死锁检测方法有多种，从简单的例子开始，即每种资源类型只有一个资源。例如，扫描仪、光盘驱动、绘图仪和打印机（仅有一台的情况）。</p>
<p>针对这种系统可以构造一张资源分配图</p>
<p>其中，圆圈指代进程，正方形指代资源</p>
<ol>
<li>A进程持有R资源，且需要S资源。</li>
<li>B进程不持有任何资源，但需要T资源</li>
<li>C进程不持有任何资源，但需要S资源。</li>
<li>D进程持有U资源，且需要S资源和T资源。</li>
<li>E进程持有T资源，且需要V资源。</li>
<li>F进程持有W资源，且需要S资源。</li>
<li>G进程持有V资源，且需要U资源。</li>
</ol>
<p>![image-20210306164921075](D:\OneDrive - e.gzhu.edu.cn\文档\blog\image-20210306164921075.png)</p>
<p>现在检测死锁的产生。从图中可以看出存在一个环（DTEVGUD），其中D、E、G已经死锁。这样的图虽然可以看出死锁进程，但是我们需要一个正规的算法来检测死锁。有很多检测有向图环路的方法。下面给出一个简单的算法，检测有向图是否存在环。这一算法使用数据结构L，L代表一些节点的集合，通过对已经检测的有向边进行标记，避免重复检查。算法流程如下：</p>
<ol>
<li>对图中的每个节点N，将N作为起始点执行下面五个步骤。</li>
<li>将L初始化为空表，并清除所有有向边标记。</li>
<li>将当前节点添加到L尾部，检测该节点是否已经在L中出现两次。如果是，那么该图包含了一个环，算法结束。</li>
<li>从给定的节点开始，检测是否存在没有标记的从该节点出发的有向边。如果存在的话，进行第5步；如果不存在，跳到第6步。</li>
<li>随机选取一条没有标记的从该节点出发的有向边，标记它，然后将该边指向的节点作为新的当前节点，跳到第3步。</li>
<li>如果这一节点是起始节点，那么表明该图不存在任何环，算法结束。否则意味着我们走进了死胡同，所以需要移走该节点，返回到前一节点，并作为新的当前节点，跳转到第3步。</li>
</ol>
<p>这一算法实际上是依次将每一个节点作为一棵树的根节点进行深度</p>
<p>优先搜索，如果碰到已经遇到过的节点，那么就算找到一个环。如果从任何给定的节点出发的有向边都被穷举了，则回溯到前面的节点。如果回溯到根，并且不能再深入下去，那么从当前节点出发的子图中就不存在环。若所有节点都是如此，则整个图不存在环，即系统不存在死锁。</p>
<p>对上图应用这一算法。从R节点开始，依次是A、B、C、S、D、T、E、F，如果遇到一个环，则算法停止。</p>
<p>我们先从R节点开始，将L初始化为空表，将R添加到L中，接着移动到A，A添加到L中，L=[R,A]。从A到达S，L=[R,A,S]。S没有出发的边，所以回溯到A，同理再回溯到R，从而完成了对R为起点的检测。</p>
<p>现在以A为起点进行检测，置L为空表，由上一段分析我们很快就能完成对A的检测。</p>
<p>现在从B节点开始，一路顺着有向边到达D，此时L=[B,T,E,V,G,U,D]。此时随机选择一条边，如果选S，则是死路，将回溯到D。接着选T，此时出现了L=[B,T,E,V,G,U,D,T]，发现了环（检测到两个T），算法结束。</p>
<h5>3.2.2 每种类型多个资源的死锁检测</h5>
<p>每种类型多种资源的情况下，可以采用基于矩阵的算法来检测死锁。现在检测$P_1$到$P_n$这n个进程中是否存在死锁，假设资源类型有m种，$E_1$代表资源类型1，$E_2$代表资源类型2，$E_i$代表资源类型$i(1\le i\le m)$。$E$是现有资源向量，代表每种已存在的资源总数，比如资源类型1代表打印机，那么$E_1=2$表示系统有两台打印机。在任意时刻，某些资源被分配所以不可用。设A是可用资源向量，那么$A_i$表示当前可供使用的资源数。如果仅有的两台打印机被分配出去，那么$A_i=0$。</p>
<p>另外需要两个矩阵，$C$代表当前分配矩阵，$R$代表请求矩阵。C的第$i$行代表$P_i$当前所持有的每一种类型资源的资源数。所以，$C_{ij}$代表$P_i$所持有的资源$j$的数量。同理，$R_{ij}$代表$P_i$所需要的资源$j$的数量。四种数据结构分别表示如下。
$$
现有资源\
(E_1,E_2,E_3,...,E_m)
$$</p>
<p>$$
可用资源\
(A_1,A_2,A_3,...,A_m)
$$</p>
<p>$$
当前分配矩阵\
\left[
\begin{matrix}
C_{11}&amp;C_{12}&amp;C_{13}&amp; ... &amp;C_{1m}\
C_{21}&amp;C_{22}&amp;C_{23}&amp; ... &amp;C_{2m}\
\vdots &amp; \vdots &amp; \vdots &amp;  &amp; \vdots    \
C_{n1}&amp;C_{n2}&amp;C_{n3}&amp; ... &amp;C_{nm}\
\end{matrix}
\right]
$$</p>
<p>$$
请求矩阵\
\left[
\begin{matrix}
R_{11}&amp;R_{12}&amp;R_{13}&amp; ... &amp;R_{1m}\
R_{21}&amp;R_{22}&amp;R_{23}&amp; ... &amp;R_{2m}\
\vdots &amp; \vdots &amp; \vdots &amp;  &amp; \vdots    \
R_{n1}&amp;R_{n2}&amp;R_{n3}&amp; ... &amp;R_{nm}\
\end{matrix}
\right]
$$</p>
<p>这四种数据结构之间满足一个恒等式，即
$$
\sum_{i=1}^nC_{ij} + A_j = E_j
$$
上式表示，将所有已分配的资源$j$数量累加起来，并且加上资源j的可用资源数，等于该类资源的总数。</p>
<p>定义向量A和向量B之间的关系为$A\le B$当且仅当$A_i \le B_i(0 \le i \le m)$。</p>
<p>规定：每个进程初始未被标记，当算法开始后，会对进程做标记，被标记后即表明该进程能够被执行，不会进入死锁。因此，当算法结束时，未被标记的进程都是死锁进程。</p>
<p>死锁检测算法如下：</p>
<ol>
<li>需要一个没有标记的进程$P_i$，对于它而言R矩阵的第$i$行向量小于或等于A，即$R_{i}\le A$.</li>
<li>如果找到这样一个进程，那么将C矩阵的第$i$行向量加到A中（因为资源足够该进程运行），标记该进程，并转到第1步。</li>
<li>如果没有这样的进程，算法结束。</li>
</ol>
<h5>3.2.3 何时去检测死锁</h5>
<p>知道了如何去检测死锁，那么该在何时去检测他们呢。一种方法是每当有资源请求时就去检测，这种方法会占用昂贵的CPU时间；另一种方法是定时检测，可以每个$k$分钟检测一次，又或者在CPU使用率降到某一阈值时去检测，依据是如果死锁进程数达到一定数量，就没有多少进程可运行，那么CPU会空闲下来。</p>
<h5>3.2.4 从死锁中恢复</h5>
<p>从死锁中恢复有如下方法：</p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>杀死进程恢复</li>
</ul>
<p>抢占恢复将资源从持有进程A拿走，分配给另一个进程B，待进程B使用完毕后再分配给进程A。</p>
<p>回滚恢复需要对进程设置<strong>检查点检查</strong>。进程检查点检查就是将进程写入一个文件以备以后重启。该检查点中不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，再此时间点之前该进程获取了一些其他的资源，而在此时间点之后该进程所做的所有工作都丢失。实际上是将该进程复位到一个更早的状态，那时它还没有取得导致死锁的资源，接着将该资源分配给一个死锁进程。</p>
<p>杀死一个或若干个进程是最直接也是最简单的解决死锁的方法。一种方法是杀掉环中的一个进程，使得其他进程可以继续，如无法继续，则再杀掉一个进程，直到打破死锁循环。另一种方法是选一个环外的进程作为牺牲品，释放该进程的资源。这种方法需要小心选择一个环外进程，它应该正好持有环中某些进程需要的资源。杀死进程这类方法，最好是选择可以从头开始重新运行而不会带来副作用的进程。例如编译程序可以重新运行产生新的目标文件。</p>
<h4>3.3 死锁避免</h4>
]]></content:encoded>
    </item>
    <item>
      <title>【后端开发】项目日志建设之流水日志和程序日志的区分</title>
      <link>https://shzyjbr.github.com/person-database/person-database/java/dif-between-transactionlog-and-programlog.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/java/dif-between-transactionlog-and-programlog.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">【后端开发】项目日志建设之流水日志和程序日志的区分</source>
      <description>拉个Star 如果本知识库的内容帮助到你，还请点个免费的Star，感谢。传送门：GitHub 项目日志建设之流水日志和程序日志的区分 最近项目要求对程序日志进行两类区分，将日志大体记录为流水日志和程序日志。 所谓流水日志，更详细的说是请求响应流水日志，记录的是系统执行的web请求、响应的内容。其主要方面一般包括后端接口调用、后端调用其他服务接口的请求与...</description>
      <category>项目实践</category>
      <pubDate>Fri, 08 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">拉个Star</p>
<ul>
<li>如果<a href="https://github.com/shzyjbr/person-database" target="blank">本知识库</a>的内容帮助到你，还请点个免费的Star，感谢。传送门：<a href="https://github.com/shzyjbr/person-database" target="blank">GitHub</a></li>
</ul>
</div>
<h1>项目日志建设之流水日志和程序日志的区分</h1>
<p>最近项目要求对程序日志进行两类区分，将日志大体记录为流水日志和程序日志。</p>
<p>所谓流水日志，更详细的说是请求响应流水日志，记录的是系统执行的web请求、响应的内容。其主要方面一般包括后端接口调用、后端调用其他服务接口的请求与响应日志。如果项目有对外向其他系统暴露服务，那么还需要包括其他服务调用本系统接口的请求响应日志。</p>
<p>而程序日志则是我们原来熟知的在程序中记录的一些常规日志，如记录异常请求处理、运行中一些助于排查的信息记录等，可以说是除了流水日志外的其他日志。</p>
<p>另一方面，在区分流水日志和程序日志的基础上，还希望将debug、info、warn、error等不同级别的日志写入不同的日志文件中，方便查看。</p>
<h2>如何去做这样的一个日志区分呢？</h2>
<p>在动手编写日志配置文件之前，我们可以大概设想一下我们需要的日志文件结构。举个例子，按照以上要求，对于流水日志，我们需要内容为流水类型且日志级别为info的日志文件，..., 内容为流水类型且日志级别为error的日志文件。为方便后续描述，我们可以将流水用transaction表示，程序用program表示。日志命名格式上，我们可以采用<code>项目名_日志类型-日志级别-日期.log</code>来命名。举个例子，有一个项目名为xxx-gateway，那么这个项目在2023年8月29日这天的info级别的流水日志，可以命名为<code>xxx-gateway_transaction-info-2023-08-29.log</code>，同理还有<code>xxx-gateway_transaction-debug-2023-08-29.log</code>、<code>xxx-gateway_transaction-warn-2023-08-29.log</code>和<code>xxx-gateway_transaction-error-2023-08-29.log</code>。对于程序日志则有<code>xxx-gateway_program-info-2023-08-29.log</code>、<code>xxx-gateway_program-warn-2023-08-29.log</code>等，其他不再列举。
总结一下，假设日志目录为logs，文件结构如下:</p>
<div class="language-C" data-ext="C" data-title="C"><pre class="language-C"><code>-logs
    - xxx-gateway_transaction-debug-2023-08-29.log
    - xxx-gateway_transaction-info-2023-08-29.log
    - xxx-gateway_transaction-warn-2023-08-29.log
    - xxx-gateway_transaction-error-2023-08-29.log
    - xxx-gateway_program-error-2023-08-29.log
    - xxx-gateway_program-info-2023-08-29.log
    - xxx-gateway_program-warn-2023-08-29.log
    - xxx-gateway_program-error-2023-08-29.log
</code></pre></div><p>本文采用的日志框架是logback，在Spring Boot项目中搭配使用。</p>
<h2>具体做法</h2>
<h3>1. 定义appender</h3>
<p>根据以上思路，我们需要在logback配置文件（本文是logback-spring.xml）中配置八个appender来实现向上述八个不同日志文件写入不同日志级别的日志记录。</p>
<p>以写入<code>xxx-gateway_transaction-info-2023-08-29.log</code>的appender为例，我们拆解一下这样一个appender需要什么配置，相关的注释我都标注在代码上了</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}_transaction-info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--日志文档输出格式--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.encoder.LayoutWrappingEncoder<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.gateway.log.layout.TransactionLayout<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appName</span><span class="token punctuation">&gt;</span></span>${APP_NAME}_info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appName</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 设置字符集 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${LOG_HOME}/${APP_NAME}-info-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>1024MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!--日志文档保留天数--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 此日志文档只记录info级别的 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>&lt;appender&gt;</code>:我将这个appender命名为TRANSACTION_INFO_FILE，表示它是用来写入请求响应流水日志且为info级别的日志文件。class选择logback提供的一个类，该类可以进行日志文件的滚动更新。所谓滚动更新用大白话解释就是，怎么分割归档文件。主要看<code>&lt;rollingPolicy&gt;</code>中的配置,当前例子是%d{yyyy-MM-dd}，也就是按不同的日期进行归档（%i作用是当文件大小太大则按1024MB分割出文件进行标号）</p>
<p><code>&lt;File&gt;</code>标签中的${LOG_HOME}这些都是自定义的变量，比如我的项目的LOG_HOME就是logs，${APP_NAME}就是项目名称，比如在这里就是xxx-gateway，因此组合起来的文件命名格式就是上文描述的格式。</p>
<p><code>&lt;encoder&gt;</code>用来自定义一条日志打印的具体格式，在这里不再展开，这里有我写的一篇关于自定义日志格式的文章:<a href="./logback-custom-log-formattion" target="blank">logback自定义日志格式，以json格式为例</a>，可以参考。</p>
<p><code>&lt;rollingPolicy&gt;</code>标签使用到logback提供的TimeBasedRollingPolicy，这意味着日志文件将根据大小和时间限制进行滚动。<code>&lt;fileNamePattern&gt;</code>指定滚动的时候文件名的格式，<code>&lt;timeBasedFileNamingAndTriggeringPolicy&gt;</code>用于控制日志文件大小到达某一阈值需要进行切分。<code>&lt;maxHistory&gt;</code>用于控制归档的日志留存的时长，单位是天。</p>
<p><code>&lt;filter&gt;</code>表达的意义是这是一个只接受INFO级别日志事件的级别筛选器。对于任何非INFO级别的日志事件都将被拒绝。</p>
<p>因此，这个appender做的事情就是，定义了请求响应流水日志且日志级别为info的日志要输出到<code>${LOG_HOME}/${APP_NAME}_transaction-info.log</code>这个文件中。滚动策略是先根据日期将日志记录到不同的文件中，然后根据文件大小滚动每个日期的日志文件。这样可以实现按天滚动的基础上，再根据文件大小进行滚动的效果。日志布局也就是日志的打印格式通过com.xxx.gateway.log.layout.TransactionLayout进行自定义。</p>
<p>按照以上做法，我们可以依葫芦画瓢，定义出另外7个appender。</p>
<h3>2. 定义logger</h3>
<p>logger称作日志记录器，用于定义某一日志记录器的行为
以下面这个root记录器为例</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PROGRAM_ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul>
<li>level: 指定root日志记录器的日志级别为"info"。这意味着root日志记录器将记录所有"info"级别及以上的日志消息，而低于"info"级别的消息将被忽略。注意！这里是info及以上！</li>
<li>additivity: 是否启用日志事件的传播。如果设置为"false"，则root日志记录器的日志消息将只被发送到指定的appender，并不会传播到其他日志记录器。如果设置为"true"，则日志消息将传播给其他适用的日志记录器，也就是一条日志被root日志记录器消费掉了，独占。</li>
<li>appender-ref: 引用了四个不同的appender，分别是"PROGRAM_INFO_FILE"、"PROGRAM_WARN_FILE"、"PROGRAM_ERROR_FILE"和"STDOUT"。这些引用定义了将日志消息发送到哪些appender进行记录。也就是一条消息会被发往这四个appender,这些appender会根据自己的配置去决定是否记录该日志。</li>
</ul>
<p>以上这个日志记录器就可以作为我们项目中的程序日志记录器，通常我们在类中通过<code>private static Logger log = org.slf4j.LoggerFactory.getLogger(AnyExample.class);</code>定义出来的log对象就会使用到这个日志记录器，包括使用@Slf4j注解也一样。</p>
<p>而针对流水日志记录器，配置如下：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>web_transaction_logger<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TRANSACTION_ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>该logger 多了一个名字，也就是"web_transaction_logger"。在代码中，当我们需要记录流水日志时，我们需要这样引用该logger:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> transactionlogger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">"web_transaction_logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过这种方式，我们将程序日志和流水日志进行了区分。
这种配置的一个好处是可以无侵入地在旧有项目上对程序日志和流水日志进行区分。原先代码中打日志的地方，我们都可以不做改动，默认作为程序日志，而针对web请求响应，我们可以在诸如filter等地方使用web_transaction_logger进行记录。</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于分享内容</title>
      <link>https://shzyjbr.github.com/person-database/person-database/life/comeon.html</link>
      <guid>https://shzyjbr.github.com/person-database/person-database/life/comeon.html</guid>
      <source url="https://shzyjbr.github.com/person-database/person-database/rss.xml">关于分享内容</source>
      <description>分享内容 生活分享的内容写在这里</description>
      <pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2>分享内容</h2>
<p>生活分享的内容写在这里</p>
]]></content:encoded>
    </item>
  </channel>
</rss>